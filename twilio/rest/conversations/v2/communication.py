r"""
    This code was generated by
   ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
    |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
    |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \

    Maestro (Conversations)
    Manage configurations, conversations, participants, and communications. Create configurations to define capture rules and channel settings, then use conversations to group related communications.

    NOTE: This class is auto generated by OpenAPI Generator.
    https://openapi-generator.tech
    Do not edit the class manually.
"""


from datetime import date, datetime
from typing import Any, Dict, List, Optional, Union, Iterator, AsyncIterator, Protocol
from twilio.base import deserialize, serialize, values
from twilio.base.api_response import ApiResponse
from twilio.base.instance_context import InstanceContext
from twilio.base.instance_resource import InstanceResource
from twilio.base.list_resource import ListResource
from twilio.base.version import Version
from twilio.base.token_pagination import TokenPagination



class CommunicationInstance(InstanceResource):

    class ContentTranscriptionTranscription(object):
        """
            :ivar channel: 
            :ivar confidence: 
            :ivar engine: 
        """

        def __init__(self, payload: Dict[str, Any]):

            
            self.channel: Optional[int] = deserialize.integer(payload.get("channel"))
            self.confidence: Optional[float] = deserialize.decimal(payload.get("confidence"))
            self.engine: Optional[str] = payload.get("engine")

        def to_dict(self):
            return {
                
                    "channel": self.channel,
                    "confidence": self.confidence,
                    "engine": self.engine,
            }

    class ConversationsV2ContentTranscriptionTranscription(object):
        """
            :ivar channel: Audio channel identifier (0 for inbound, 1 for outbound).
            :ivar confidence: Overall confidence score for the transcription (0.0-1.0).
            :ivar engine: Transcription engine used.
            :ivar words: Word-level transcription data with timing information.
        """

        def __init__(self, payload: Dict[str, Any]):

            
            self.channel: Optional[int] = deserialize.integer(payload.get("channel"))
            self.confidence: Optional[float] = payload.get("confidence")
            self.engine: Optional[str] = payload.get("engine")
            self.words: Optional[List[ConversationsV2ContentTranscriptionTranscriptionWords]] = payload.get("words")

        def to_dict(self):
            return {
                
                    "channel": self.channel,
                    "confidence": self.confidence,
                    "engine": self.engine,
                    "words": [words.to_dict() for words in self.words] if self.words is not None else None,
            }

    class ConversationsV2ContentTranscriptionTranscriptionWords(object):
        """
            :ivar text: The transcribed word.
            :ivar start_time: Start timestamp of this word.
            :ivar end_time: End timestamp of this word.
        """

        def __init__(self, payload: Dict[str, Any]):

            
            self.text: Optional[str] = payload.get("text")
            self.start_time: Optional[datetime] = deserialize.iso8601_datetime(payload.get("startTime"))
            self.end_time: Optional[datetime] = deserialize.iso8601_datetime(payload.get("endTime"))

        def to_dict(self):
            return {
                
                    "text": self.text,
                    "startTime": self.start_time,
                    "endTime": self.end_time,
            }

    class CreateCommunicationInConversationRequest(object):
        """
            :ivar author: 
            :ivar content: 
            :ivar channel_id: 
            :ivar recipients: 
        """

        def __init__(self, payload: Dict[str, Any]):

            
            self.author: Optional[CommunicationList.CreateCommunicationInConversationRequestAuthor] = payload.get("author")
            self.content: Optional[CommunicationList.CreateCommunicationInConversationRequestContent] = payload.get("content")
            self.channel_id: Optional[str] = payload.get("channelId")
            self.recipients: Optional[List[CommunicationList.CreateCommunicationInConversationRequestAuthor]] = payload.get("recipients")

        def to_dict(self):
            return {
                
                    "author": self.author.to_dict() if self.author is not None else None ,
                    "content": self.content.to_dict() if self.content is not None else None ,
                    "channelId": self.channel_id,
                    "recipients": [recipients.to_dict() for recipients in self.recipients] if self.recipients is not None else None,
            }

    class CreateCommunicationInConversationRequestAuthor(object):
        """
            :ivar address: 
            :ivar channel: 
            :ivar participant_id: 
        """

        def __init__(self, payload: Dict[str, Any]):

            
            self.address: Optional[str] = payload.get("address")
            self.channel: Optional["CommunicationInstance.str"] = payload.get("channel")
            self.participant_id: Optional[str] = payload.get("participantId")

        def to_dict(self):
            return {
                
                    "address": self.address,
                    "channel": self.channel,
                    "participantId": self.participant_id,
            }

    class CreateCommunicationInConversationRequestContent(object):
        """
            :ivar type: 
            :ivar text: 
            :ivar transcription: 
        """

        def __init__(self, payload: Dict[str, Any]):

            
            self.type: Optional["CommunicationInstance.str"] = payload.get("type")
            self.text: Optional[str] = payload.get("text")
            self.transcription: Optional[CommunicationList.ContentTranscriptionTranscription] = payload.get("transcription")

        def to_dict(self):
            return {
                
                    "type": self.type,
                    "text": self.text,
                    "transcription": self.transcription.to_dict() if self.transcription is not None else None ,
            }



    """
    :ivar id: Communication ID.
    :ivar conversation_id: Conversation ID.
    :ivar account_id: Account ID.
    :ivar author: 
    :ivar content: 
    :ivar channel_id: Channel-specific reference ID.
    :ivar recipients: Communication recipients.
    :ivar created_at: Timestamp when this Communication was created.
    :ivar updated_at: Timestamp when this Communication was last updated.
    """

    def __init__(self, version: Version, payload:Dict[str, Any], conversation_sid: Optional[str] = None, sid: Optional[str] = None):
        super().__init__(version)

        
        self.id: Optional[str] = payload.get("id")
        self.conversation_id: Optional[str] = payload.get("conversationId")
        self.account_id: Optional[str] = payload.get("accountId")
        self.author: Optional[str] = payload.get("author")
        self.content: Optional[str] = payload.get("content")
        self.channel_id: Optional[str] = payload.get("channelId")
        self.recipients: Optional[List[str]] = payload.get("recipients")
        self.created_at: Optional[datetime] = deserialize.iso8601_datetime(payload.get("createdAt"))
        self.updated_at: Optional[datetime] = deserialize.iso8601_datetime(payload.get("updatedAt"))

        
        self._solution = { 
            "conversation_sid": conversation_sid or self.conversation_sid,
            "sid": sid or self.sid,
        }
        self._context: Optional[CommunicationContext] = None

    @property
    def _proxy(self) -> "CommunicationContext":
        """
        Generate an instance context for the instance, the context is capable of
        performing various actions. All instance actions are proxied to the context

        :returns: CommunicationContext for this CommunicationInstance
        """
        if self._context is None:
            self._context = CommunicationContext(self._version, conversation_sid=self._solution['conversation_sid'], sid=self._solution['sid'],)
        return self._context
    
    
    def fetch(self) -> "CommunicationInstance":
        """
        Fetch the CommunicationInstance
        

        :returns: The fetched CommunicationInstance
        """
        return self._proxy.fetch()

    async def fetch_async(self) -> "CommunicationInstance":
        """
        Asynchronous coroutine to fetch the CommunicationInstance
        

        :returns: The fetched CommunicationInstance
        """
        return await self._proxy.fetch_async()

    def fetch_with_http_info(self) -> ApiResponse:
        """
        Fetch the CommunicationInstance with HTTP info
        

        :returns: ApiResponse with instance, status code, and headers
        """
        return self._proxy.fetch_with_http_info()

    async def fetch_with_http_info_async(self) -> ApiResponse:
        """
        Asynchronous coroutine to fetch the CommunicationInstance with HTTP info
        

        :returns: ApiResponse with instance, status code, and headers
        """
        return await self._proxy.fetch_with_http_info_async()
    
    def __repr__(self) -> str:
        """
        Provide a friendly representation

        :returns: Machine friendly representation
        """
        context = ' '.join('{}={}'.format(k, v) for k, v in self._solution.items())
        return '<Twilio.Conversations.V2.CommunicationInstance {}>'.format(context)

class CommunicationContext(InstanceContext):

    class ContentTranscriptionTranscription(object):
        """
            :ivar channel: 
            :ivar confidence: 
            :ivar engine: 
        """

        def __init__(self, payload: Dict[str, Any]):

            
            self.channel: Optional[int] = deserialize.integer(payload.get("channel"))
            self.confidence: Optional[float] = deserialize.decimal(payload.get("confidence"))
            self.engine: Optional[str] = payload.get("engine")

        def to_dict(self):
            return {
                
                    "channel": self.channel,
                    "confidence": self.confidence,
                    "engine": self.engine,
            }

    class ConversationsV2ContentTranscriptionTranscription(object):
        """
            :ivar channel: Audio channel identifier (0 for inbound, 1 for outbound).
            :ivar confidence: Overall confidence score for the transcription (0.0-1.0).
            :ivar engine: Transcription engine used.
            :ivar words: Word-level transcription data with timing information.
        """

        def __init__(self, payload: Dict[str, Any]):

            
            self.channel: Optional[int] = deserialize.integer(payload.get("channel"))
            self.confidence: Optional[float] = payload.get("confidence")
            self.engine: Optional[str] = payload.get("engine")
            self.words: Optional[List[ConversationsV2ContentTranscriptionTranscriptionWords]] = payload.get("words")

        def to_dict(self):
            return {
                
                    "channel": self.channel,
                    "confidence": self.confidence,
                    "engine": self.engine,
                    "words": [words.to_dict() for words in self.words] if self.words is not None else None,
            }

    class ConversationsV2ContentTranscriptionTranscriptionWords(object):
        """
            :ivar text: The transcribed word.
            :ivar start_time: Start timestamp of this word.
            :ivar end_time: End timestamp of this word.
        """

        def __init__(self, payload: Dict[str, Any]):

            
            self.text: Optional[str] = payload.get("text")
            self.start_time: Optional[datetime] = deserialize.iso8601_datetime(payload.get("startTime"))
            self.end_time: Optional[datetime] = deserialize.iso8601_datetime(payload.get("endTime"))

        def to_dict(self):
            return {
                
                    "text": self.text,
                    "startTime": self.start_time,
                    "endTime": self.end_time,
            }

    class CreateCommunicationInConversationRequest(object):
        """
            :ivar author: 
            :ivar content: 
            :ivar channel_id: 
            :ivar recipients: 
        """

        def __init__(self, payload: Dict[str, Any]):

            
            self.author: Optional[CommunicationList.CreateCommunicationInConversationRequestAuthor] = payload.get("author")
            self.content: Optional[CommunicationList.CreateCommunicationInConversationRequestContent] = payload.get("content")
            self.channel_id: Optional[str] = payload.get("channelId")
            self.recipients: Optional[List[CommunicationList.CreateCommunicationInConversationRequestAuthor]] = payload.get("recipients")

        def to_dict(self):
            return {
                
                    "author": self.author.to_dict() if self.author is not None else None ,
                    "content": self.content.to_dict() if self.content is not None else None ,
                    "channelId": self.channel_id,
                    "recipients": [recipients.to_dict() for recipients in self.recipients] if self.recipients is not None else None,
            }

    class CreateCommunicationInConversationRequestAuthor(object):
        """
            :ivar address: 
            :ivar channel: 
            :ivar participant_id: 
        """

        def __init__(self, payload: Dict[str, Any]):

            
            self.address: Optional[str] = payload.get("address")
            self.channel: Optional["CommunicationInstance.str"] = payload.get("channel")
            self.participant_id: Optional[str] = payload.get("participantId")

        def to_dict(self):
            return {
                
                    "address": self.address,
                    "channel": self.channel,
                    "participantId": self.participant_id,
            }

    class CreateCommunicationInConversationRequestContent(object):
        """
            :ivar type: 
            :ivar text: 
            :ivar transcription: 
        """

        def __init__(self, payload: Dict[str, Any]):

            
            self.type: Optional["CommunicationInstance.str"] = payload.get("type")
            self.text: Optional[str] = payload.get("text")
            self.transcription: Optional[CommunicationList.ContentTranscriptionTranscription] = payload.get("transcription")

        def to_dict(self):
            return {
                
                    "type": self.type,
                    "text": self.text,
                    "transcription": self.transcription.to_dict() if self.transcription is not None else None ,
            }


    def __init__(self, version: Version, conversation_sid: str, sid: str):
        """
        Initialize the CommunicationContext

        :param version: Version that contains the resource
        :param conversation_sid: 
        :param sid: 
        """
        super().__init__(version)

        
        # Path Solution
        self._solution = { 
            'conversation_sid': conversation_sid,
            'sid': sid,
        }
        self._uri = '/Conversations/{conversation_sid}/Communications/{sid}'.format(**self._solution)
        
    
    
    def _fetch(self) -> tuple:
        """
        Internal helper for fetch operation

        Returns:
            tuple: (payload, status_code, headers)
        """
        

        headers = values.of({})
        
        
        
        headers["Accept"] = "application/json"
        
        return self._version.fetch_with_response_info(method='GET', uri=self._uri, headers=headers)

    def fetch(self) -> CommunicationInstance:
        """
        Fetch the CommunicationInstance
        

        :returns: The fetched CommunicationInstance
        """
        payload, _, _ = self._fetch()
        return CommunicationInstance(
            self._version,
            payload,
            conversation_sid=self._solution['conversation_sid'],
            sid=self._solution['sid'],
            
        )

    def fetch_with_http_info(self) -> ApiResponse:
        """
        Fetch the CommunicationInstance and return response metadata
        

        :returns: ApiResponse with instance, status code, and headers
        """
        payload, status_code, headers = self._fetch()
        instance = CommunicationInstance(
            self._version,
            payload,
            conversation_sid=self._solution['conversation_sid'],
            sid=self._solution['sid'],
            
        )
        return ApiResponse(data=instance, status_code=status_code, headers=headers)

    async def _fetch_async(self) -> tuple:
        """
        Internal async helper for fetch operation

        Returns:
            tuple: (payload, status_code, headers)
        """
        

        headers = values.of({})
        
        
        
        headers["Accept"] = "application/json"
        
        return await self._version.fetch_with_response_info_async(method='GET', uri=self._uri, headers=headers)

    async def fetch_async(self) -> CommunicationInstance:
        """
        Asynchronous coroutine to fetch the CommunicationInstance
        

        :returns: The fetched CommunicationInstance
        """
        payload, _, _ = await self._fetch_async()
        return CommunicationInstance(
            self._version,
            payload,
            conversation_sid=self._solution['conversation_sid'],
            sid=self._solution['sid'],
            
        )

    async def fetch_with_http_info_async(self) -> ApiResponse:
        """
        Asynchronous coroutine to fetch the CommunicationInstance and return response metadata
        

        :returns: ApiResponse with instance, status code, and headers
        """
        payload, status_code, headers = await self._fetch_async()
        instance = CommunicationInstance(
            self._version,
            payload,
            conversation_sid=self._solution['conversation_sid'],
            sid=self._solution['sid'],
            
        )
        return ApiResponse(data=instance, status_code=status_code, headers=headers)
    
    
    def __repr__(self) -> str:
        """
        Provide a friendly representation

        :returns: Machine friendly representation
        """
        context = ' '.join('{}={}'.format(k, v) for k, v in self._solution.items())
        return '<Twilio.Conversations.V2.CommunicationContext {}>'.format(context)







class CommunicationPage(TokenPagination):

    def get_instance(self, payload: Dict[str, Any]) -> CommunicationInstance:
        """
        Build an instance of CommunicationInstance

        :param payload: Payload response from the API
        """
        return CommunicationInstance(self._version, payload, conversation_sid=self._solution["conversation_sid"])

    def __repr__(self) -> str:
        """
        Provide a friendly representation

        :returns: Machine friendly representation
        """
        return "<Twilio.Conversations.V2.CommunicationPage>"





class CommunicationList(ListResource):
    
    class ContentTranscriptionTranscription(object):
        """
            :ivar channel: 
            :ivar confidence: 
            :ivar engine: 
        """

        def __init__(self, payload: Dict[str, Any]):

            
            self.channel: Optional[int] = deserialize.integer(payload.get("channel"))
            self.confidence: Optional[float] = deserialize.decimal(payload.get("confidence"))
            self.engine: Optional[str] = payload.get("engine")

        def to_dict(self):
            return {
                
                    "channel": self.channel,
                    "confidence": self.confidence,
                    "engine": self.engine,
            }

    class ConversationsV2ContentTranscriptionTranscription(object):
        """
            :ivar channel: Audio channel identifier (0 for inbound, 1 for outbound).
            :ivar confidence: Overall confidence score for the transcription (0.0-1.0).
            :ivar engine: Transcription engine used.
            :ivar words: Word-level transcription data with timing information.
        """

        def __init__(self, payload: Dict[str, Any]):

            
            self.channel: Optional[int] = deserialize.integer(payload.get("channel"))
            self.confidence: Optional[float] = payload.get("confidence")
            self.engine: Optional[str] = payload.get("engine")
            self.words: Optional[List[ConversationsV2ContentTranscriptionTranscriptionWords]] = payload.get("words")

        def to_dict(self):
            return {
                
                    "channel": self.channel,
                    "confidence": self.confidence,
                    "engine": self.engine,
                    "words": [words.to_dict() for words in self.words] if self.words is not None else None,
            }

    class ConversationsV2ContentTranscriptionTranscriptionWords(object):
        """
            :ivar text: The transcribed word.
            :ivar start_time: Start timestamp of this word.
            :ivar end_time: End timestamp of this word.
        """

        def __init__(self, payload: Dict[str, Any]):

            
            self.text: Optional[str] = payload.get("text")
            self.start_time: Optional[datetime] = deserialize.iso8601_datetime(payload.get("startTime"))
            self.end_time: Optional[datetime] = deserialize.iso8601_datetime(payload.get("endTime"))

        def to_dict(self):
            return {
                
                    "text": self.text,
                    "startTime": self.start_time,
                    "endTime": self.end_time,
            }

    class CreateCommunicationInConversationRequest(object):
        """
            :ivar author: 
            :ivar content: 
            :ivar channel_id: 
            :ivar recipients: 
        """

        def __init__(self, payload: Dict[str, Any]):

            
            self.author: Optional[CommunicationList.CreateCommunicationInConversationRequestAuthor] = payload.get("author")
            self.content: Optional[CommunicationList.CreateCommunicationInConversationRequestContent] = payload.get("content")
            self.channel_id: Optional[str] = payload.get("channelId")
            self.recipients: Optional[List[CommunicationList.CreateCommunicationInConversationRequestAuthor]] = payload.get("recipients")

        def to_dict(self):
            return {
                
                    "author": self.author.to_dict() if self.author is not None else None ,
                    "content": self.content.to_dict() if self.content is not None else None ,
                    "channelId": self.channel_id,
                    "recipients": [recipients.to_dict() for recipients in self.recipients] if self.recipients is not None else None,
            }

    class CreateCommunicationInConversationRequestAuthor(object):
        """
            :ivar address: 
            :ivar channel: 
            :ivar participant_id: 
        """

        def __init__(self, payload: Dict[str, Any]):

            
            self.address: Optional[str] = payload.get("address")
            self.channel: Optional["CommunicationInstance.str"] = payload.get("channel")
            self.participant_id: Optional[str] = payload.get("participantId")

        def to_dict(self):
            return {
                
                    "address": self.address,
                    "channel": self.channel,
                    "participantId": self.participant_id,
            }

    class CreateCommunicationInConversationRequestContent(object):
        """
            :ivar type: 
            :ivar text: 
            :ivar transcription: 
        """

        def __init__(self, payload: Dict[str, Any]):

            
            self.type: Optional["CommunicationInstance.str"] = payload.get("type")
            self.text: Optional[str] = payload.get("text")
            self.transcription: Optional[CommunicationList.ContentTranscriptionTranscription] = payload.get("transcription")

        def to_dict(self):
            return {
                
                    "type": self.type,
                    "text": self.text,
                    "transcription": self.transcription.to_dict() if self.transcription is not None else None ,
            }


    def __init__(self, version: Version, conversation_sid: str):
        """
        Initialize the CommunicationList

        :param version: Version that contains the resource
        :param conversation_sid: 
        
        """
        super().__init__(version)

        
        # Path Solution
        self._solution = { 'conversation_sid': conversation_sid,  }
        self._uri = '/Conversations/{conversation_sid}/Communications'.format(**self._solution)
        
        
    
    
    def _create(self, create_communication_in_conversation_request: Union[CreateCommunicationInConversationRequest, object]=values.unset) -> tuple:
        """
        Internal helper for create operation

        Returns:
            tuple: (payload, status_code, headers)
        """
        data = create_communication_in_conversation_request.to_dict()
        
        headers = values.of({
                'Content-Type': 'application/x-www-form-urlencoded'
            })
        
        headers["Content-Type"] = "application/json"
        
        
        headers["Accept"] = "application/json"
        
        
        return self._version.create_with_response_info(method='POST', uri=self._uri, data=data, headers=headers)

    def create(self, create_communication_in_conversation_request: Union[CreateCommunicationInConversationRequest, object]=values.unset) -> CommunicationInstance:
        """
        Create the CommunicationInstance

        :param create_communication_in_conversation_request: 
        
        :returns: The created CommunicationInstance
        """
        payload, _, _ = self._create(create_communication_in_conversation_request=create_communication_in_conversation_request)
        return CommunicationInstance(self._version, payload, conversation_sid=self._solution['conversation_sid'])

    def create_with_http_info(self, create_communication_in_conversation_request: Union[CreateCommunicationInConversationRequest, object]=values.unset) -> ApiResponse:
        """
        Create the CommunicationInstance and return response metadata

        :param create_communication_in_conversation_request: 
        
        :returns: ApiResponse with instance, status code, and headers
        """
        payload, status_code, headers = self._create(create_communication_in_conversation_request=create_communication_in_conversation_request)
        instance = CommunicationInstance(self._version, payload, conversation_sid=self._solution['conversation_sid'])
        return ApiResponse(data=instance, status_code=status_code, headers=headers)

    async def _create_async(self, create_communication_in_conversation_request: Union[CreateCommunicationInConversationRequest, object]=values.unset) -> tuple:
        """
        Internal async helper for create operation

        Returns:
            tuple: (payload, status_code, headers)
        """
        data = create_communication_in_conversation_request.to_dict()
        
        headers = values.of({
                'Content-Type': 'application/x-www-form-urlencoded'
            })
        
        headers["Content-Type"] = "application/json"
        
        
        headers["Accept"] = "application/json"
        
        
        return await self._version.create_with_response_info_async(method='POST', uri=self._uri, data=data, headers=headers)

    async def create_async(self, create_communication_in_conversation_request: Union[CreateCommunicationInConversationRequest, object]=values.unset) -> CommunicationInstance:
        """
        Asynchronously create the CommunicationInstance

        :param create_communication_in_conversation_request: 
        
        :returns: The created CommunicationInstance
        """
        payload, _, _ = await self._create_async(create_communication_in_conversation_request=create_communication_in_conversation_request)
        return CommunicationInstance(self._version, payload, conversation_sid=self._solution['conversation_sid'])

    async def create_with_http_info_async(self, create_communication_in_conversation_request: Union[CreateCommunicationInConversationRequest, object]=values.unset) -> ApiResponse:
        """
        Asynchronously create the CommunicationInstance and return response metadata

        :param create_communication_in_conversation_request: 
        
        :returns: ApiResponse with instance, status code, and headers
        """
        payload, status_code, headers = await self._create_async(create_communication_in_conversation_request=create_communication_in_conversation_request)
        instance = CommunicationInstance(self._version, payload, conversation_sid=self._solution['conversation_sid'])
        return ApiResponse(data=instance, status_code=status_code, headers=headers)
    
    
    def stream(self, 
        channel_id: Union[str, object] = values.unset,
        
        page_token: Union[str, object] = values.unset,
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> Iterator[CommunicationInstance]:
        """
        Streams CommunicationInstance records from the API as a generator stream.
        This operation lazily loads records as efficiently as possible until the limit
        is reached.
        The results are returned as a generator, so this operation is memory efficient.
        
        :param str channel_id: Resource identifier to filter communications
        :param str page_token: Page token for pagination
        :param limit: Upper limit for the number of records to return. stream()
                      guarantees to never return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, stream() will attempt to read the
                          limit with the most efficient page size, i.e. min(limit, 1000)

        :returns: Generator that will yield up to limit results
        """
        limits = self._version.read_limits(limit, page_size)
        page = self.page(
            channel_id=channel_id,
            page_token=page_token,
            page_size=limits['page_size']
        )

        return self._version.stream(page, limits['limit'])

    async def stream_async(self, 
        channel_id: Union[str, object] = values.unset,
        
        page_token: Union[str, object] = values.unset,
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> AsyncIterator[CommunicationInstance]:
        """
        Asynchronously streams CommunicationInstance records from the API as a generator stream.
        This operation lazily loads records as efficiently as possible until the limit
        is reached.
        The results are returned as a generator, so this operation is memory efficient.
        
        :param str channel_id: Resource identifier to filter communications
        :param str page_token: Page token for pagination
        :param limit: Upper limit for the number of records to return. stream()
                      guarantees to never return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, stream() will attempt to read the
                          limit with the most efficient page size, i.e. min(limit, 1000)

        :returns: Generator that will yield up to limit results
        """
        limits = self._version.read_limits(limit, page_size)
        page = await self.page_async(
            channel_id=channel_id,
            page_token=page_token,
            page_size=limits['page_size']
        )

        return self._version.stream_async(page, limits['limit'])

    def stream_with_http_info(self, 
        channel_id: Union[str, object] = values.unset,
        
        page_token: Union[str, object] = values.unset,
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> tuple:
        """
        Streams CommunicationInstance and returns headers from first page

        
        :param str channel_id: Resource identifier to filter communications
        :param str page_token: Page token for pagination
        :param limit: Upper limit for the number of records to return. stream()
                      guarantees to never return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, stream() will attempt to read the
                          limit with the most efficient page size, i.e. min(limit, 1000)

        :returns: tuple of (generator, status_code, headers) where generator yields instances
        """
        limits = self._version.read_limits(limit, page_size)
        page_response = self.page_with_http_info(
            channel_id=channel_id,
            page_token=page_token,
            page_size=limits['page_size']
        )

        generator = self._version.stream(page_response.data, limits['limit'])
        return (generator, page_response.status_code, page_response.headers)

    async def stream_with_http_info_async(self, 
        channel_id: Union[str, object] = values.unset,
        
        page_token: Union[str, object] = values.unset,
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> tuple:
        """
        Asynchronously streams CommunicationInstance and returns headers from first page

        
        :param str channel_id: Resource identifier to filter communications
        :param str page_token: Page token for pagination
        :param limit: Upper limit for the number of records to return. stream()
                      guarantees to never return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, stream() will attempt to read the
                          limit with the most efficient page size, i.e. min(limit, 1000)

        :returns: tuple of (generator, status_code, headers) where generator yields instances
        """
        limits = self._version.read_limits(limit, page_size)
        page_response = await self.page_with_http_info_async(
            channel_id=channel_id,
            page_token=page_token,
            page_size=limits['page_size']
        )

        generator = self._version.stream_async(page_response.data, limits['limit'])
        return (generator, page_response.status_code, page_response.headers)

    def list(self, 
        channel_id: Union[str, object] = values.unset,
        
        page_token: Union[str, object] = values.unset,
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> List[CommunicationInstance]:
        """
        Lists CommunicationInstance records from the API as a list.
        Unlike stream(), this operation is eager and will load `limit` records into
        memory before returning.
        
        :param str channel_id: Resource identifier to filter communications
        :param str page_token: Page token for pagination
        :param limit: Upper limit for the number of records to return. list() guarantees
                      never to return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, list() will attempt to read the limit
                          with the most efficient page size, i.e. min(limit, 1000)

        :returns: list that will contain up to limit results
        """
        return list(self.stream(
            channel_id=channel_id,
            page_token=page_token,
            limit=limit,
            page_size=page_size,
        ))

    async def list_async(self, 
        channel_id: Union[str, object] = values.unset,
        
        page_token: Union[str, object] = values.unset,
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> List[CommunicationInstance]:
        """
        Asynchronously lists CommunicationInstance records from the API as a list.
        Unlike stream(), this operation is eager and will load `limit` records into
        memory before returning.
        
        :param str channel_id: Resource identifier to filter communications
        :param str page_token: Page token for pagination
        :param limit: Upper limit for the number of records to return. list() guarantees
                      never to return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, list() will attempt to read the limit
                          with the most efficient page size, i.e. min(limit, 1000)

        :returns: list that will contain up to limit results
        """
        return [record async for record in await self.stream_async(
            channel_id=channel_id,
            page_token=page_token,
            limit=limit,
            page_size=page_size,
        )]

    def list_with_http_info(self, 
        channel_id: Union[str, object] = values.unset,
        
        page_token: Union[str, object] = values.unset,
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> ApiResponse:
        """
        Lists CommunicationInstance and returns headers from first page

        
        :param str channel_id: Resource identifier to filter communications
        :param str page_token: Page token for pagination
        :param limit: Upper limit for the number of records to return. list() guarantees
                      never to return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, list() will attempt to read the limit
                          with the most efficient page size, i.e. min(limit, 1000)

        :returns: ApiResponse with list of instances, status code, and headers
        """
        generator, status_code, headers = self.stream_with_http_info(
            channel_id=channel_id,
            page_token=page_token,
            limit=limit,
            page_size=page_size,
        )
        items = list(generator)
        return ApiResponse(data=items, status_code=status_code, headers=headers)

    async def list_with_http_info_async(self, 
        channel_id: Union[str, object] = values.unset,
        
        page_token: Union[str, object] = values.unset,
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> ApiResponse:
        """
        Asynchronously lists CommunicationInstance and returns headers from first page

        
        :param str channel_id: Resource identifier to filter communications
        :param str page_token: Page token for pagination
        :param limit: Upper limit for the number of records to return. list() guarantees
                      never to return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, list() will attempt to read the limit
                          with the most efficient page size, i.e. min(limit, 1000)

        :returns: ApiResponse with list of instances, status code, and headers
        """
        generator, status_code, headers = await self.stream_with_http_info_async(
            channel_id=channel_id,
            page_token=page_token,
            limit=limit,
            page_size=page_size,
        )
        items = [record async for record in generator]
        return ApiResponse(data=items, status_code=status_code, headers=headers)

    def page(self, 
      channel_id: Union[str, object] = values.unset,
      page_size: Union[int, object] = values.unset,
      page_token: Union[str, object] = values.unset,
    ) -> CommunicationPage:
        """
        Retrieve a single page of CommunicationInstance records from the API.
        Request is executed immediately
        
        :param channel_id: Resource identifier to filter communications
        :param page_size: Maximum number of items to return
        :param page_token: Page token for pagination
        :returns: Page of CommunicationInstance
        """
        data = values.of({ 
            'channelId': channel_id,
            'pageSize': page_size,
            'pageToken': page_token,
        })

        headers = values.of({
        'Content-Type': 'application/x-www-form-urlencoded'
        })
        
        
        headers["Accept"] = "application/json"
        

        response = self._version.page(method='GET', uri=self._uri, params=data, headers=headers)
        return CommunicationPage(self._version, response, uri=self._uri, params=data, self._solution)

    async def page_async(self, 
      channel_id: Union[str, object] = values.unset,
      page_size: Union[int, object] = values.unset,
      page_token: Union[str, object] = values.unset,
    ) -> CommunicationPage:
        """
        Asynchronously retrieve a single page of CommunicationInstance records from the API.
        Request is executed immediately
        
        :param channel_id: Resource identifier to filter communications
        :param page_size: Maximum number of items to return
        :param page_token: Page token for pagination
        :returns: Page of CommunicationInstance
        """
        data = values.of({ 
            'channelId': channel_id,
            'pageSize': page_size,
            'pageToken': page_token,
        })

        headers = values.of({
        'Content-Type': 'application/x-www-form-urlencoded'
        })
        
        
        headers["Accept"] = "application/json"
        

        response = await self._version.page_async(method='GET', uri=self._uri, params=data, headers=headers)
        return CommunicationPage(self._version, response, uri=self._uri, params=data, self._solution)

    def page_with_http_info(self, 
        channel_id: Union[str, object] = values.unset,
        
        
        page_token: Union[str, object] = values.unset,
        page_number: Union[int, object] = values.unset,
        page_size: Union[int, object] = values.unset,
    ) -> ApiResponse:
        """
        Retrieve a single page with response metadata

        
        :param channel_id: Resource identifier to filter communications
        :param page_token: Page token for pagination
        :param page_token: PageToken provided by the API
        :param page_number: Page Number, this value is simply for client state
        :param page_size: Number of records to return, defaults to 50

        :returns: ApiResponse with CommunicationPage, status code, and headers
        """
        data = values.of({ 
            'channelId': channel_id,
            'pageToken': page_token,
            'PageToken': page_token,
            'Page': page_number,
            'PageSize': page_size,
        })

        headers = values.of({
        'Content-Type': 'application/x-www-form-urlencoded'
        })
        
        
        headers["Accept"] = "application/json"
        

        response, status_code, response_headers = self._version.page_with_response_info(method='GET', uri=self._uri, params=data, headers=headers)
        page = CommunicationPage(self._version, response, uri=self._uri, self._solution)
        return ApiResponse(data=page, status_code=status_code, headers=response_headers)

    async def page_with_http_info_async(self, 
        channel_id: Union[str, object] = values.unset,
        
        page_token: Union[str, object] = values.unset,
        page_token: Union[str, object] = values.unset,
        page_number: Union[int, object] = values.unset,
        page_size: Union[int, object] = values.unset,
    ) -> ApiResponse:
        """
        Asynchronously retrieve a single page with response metadata

        
        :param channel_id: Resource identifier to filter communications
        :param page_token: Page token for pagination
        :param page_token: PageToken provided by the API
        :param page_number: Page Number, this value is simply for client state
        :param page_size: Number of records to return, defaults to 50

        :returns: ApiResponse with CommunicationPage, status code, and headers
        """
        data = values.of({ 
            'channelId': channel_id,
            'pageToken': page_token,
            'PageToken': page_token,
            'Page': page_number,
            'PageSize': page_size,
        })

        headers = values.of({
        'Content-Type': 'application/x-www-form-urlencoded'
        })
        
        
        headers["Accept"] = "application/json"
        

        response, status_code, response_headers = await self._version.page_with_response_info_async(method='GET', uri=self._uri, params=data, headers=headers)
        page = CommunicationPage(self._version, response, self._solution)
        return ApiResponse(data=page, status_code=status_code, headers=response_headers)

    def get_page(self, target_url: str) -> CommunicationPage:
        """
        Retrieve a specific page of CommunicationInstance records from the API.
        Request is executed immediately

        :param target_url: API-generated URL for the requested results page

        :returns: Page of CommunicationInstance
        """
        response = self._version.domain.twilio.request(
            'GET',
            target_url
        )
        return CommunicationPage(self._version, response, self._solution)

    async def get_page_async(self, target_url: str) -> CommunicationPage:
        """
        Asynchronously retrieve a specific page of CommunicationInstance records from the API.
        Request is executed immediately

        :param target_url: API-generated URL for the requested results page

        :returns: Page of CommunicationInstance
        """
        response = await self._version.domain.twilio.request_async(
            'GET',
            target_url
        )
        return CommunicationPage(self._version, response, self._solution)



    def get(self, conversation_sid: str, sid: str) -> CommunicationContext:
        """
        Constructs a CommunicationContext
        
        :param conversation_sid: 
        :param sid: 
        """
        return CommunicationContext(self._version, conversation_sid=conversation_sid, sid=sid)

    def __call__(self, conversation_sid: str, sid: str) -> CommunicationContext:
        """
        Constructs a CommunicationContext
        
        :param conversation_sid: 
        :param sid: 
        """
        return CommunicationContext(self._version, conversation_sid=conversation_sid, sid=sid)

    def __repr__(self) -> str:
        """
        Provide a friendly representation

        :returns: Machine friendly representation
        """
        return '<Twilio.Conversations.V2.CommunicationList>'

