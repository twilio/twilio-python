r"""
    This code was generated by
   ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
    |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
    |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \

    Maestro (Conversations)
    Manage configurations, conversations, participants, and communications. Create configurations to define capture rules and channel settings, then use conversations to group related communications.

    NOTE: This class is auto generated by OpenAPI Generator.
    https://openapi-generator.tech
    Do not edit the class manually.
"""

from datetime import datetime
from typing import Any, Dict, List, Optional, Union, Iterator, AsyncIterator, Protocol
from twilio.base import deserialize, values
from twilio.base.api_response import ApiResponse
from twilio.base.instance_context import InstanceContext
from twilio.base.instance_resource import InstanceResource
from twilio.base.list_resource import ListResource
from twilio.base.version import Version
from twilio.base.token_pagination import TokenPagination


class ResponseResource(Protocol):
    pass


"""
Nested response model for ConversationsV2CaptureRule
"""


class ConversationsV2CaptureRule:
    def __init__(self, _from: str, to: str, metadata: Dict[str, str]):
        self._from = _from
        self.to = to
        self.metadata = metadata


"""
Nested response model for ConversationsV2ChannelSetting
"""


class ConversationsV2ChannelSetting:
    def __init__(
        self,
        status_timeouts: ConversationsV2StatusTimeouts,
        capture_rules: List[ConversationsV2CaptureRule],
    ):
        self.status_timeouts = status_timeouts
        self.capture_rules = capture_rules


"""
Nested response model for ConversationsV2StatusCallbackConfig
"""


class ConversationsV2StatusCallbackConfig:
    def __init__(self, url: str, method: str):
        self.url = url
        self.method = method


"""
Nested response model for ConversationsV2StatusTimeouts
"""


class ConversationsV2StatusTimeouts:
    def __init__(self, inactive: int, closed: int):
        self.inactive = inactive
        self.closed = closed


"""
Nested response model for CreateConfigurationRequest
"""


class CreateConfigurationRequest:
    def __init__(
        self,
        display_name: str,
        description: str,
        conversation_grouping_type: "ConfigurationInstance.str",
        memory_store_id: str,
        channel_settings: Dict[str, CreateConfigurationRequestChannelSettingsValue],
        status_callbacks: List[
            ConfigurationList.CreateConfigurationRequestStatusCallbacks
        ],
        intelligence_configuration_ids: List[str],
    ):
        self.display_name = display_name
        self.description = description
        self.conversation_grouping_type = conversation_grouping_type
        self.memory_store_id = memory_store_id
        self.channel_settings = channel_settings
        self.status_callbacks = status_callbacks
        self.intelligence_configuration_ids = intelligence_configuration_ids


"""
Nested response model for CreateConfigurationRequestChannelSettingsValue
"""


class CreateConfigurationRequestChannelSettingsValue:
    def __init__(
        self,
        status_timeouts: CreateConfigurationRequestChannelSettingsValueStatusTimeouts,
        capture_rules: List[CreateConfigurationRequestChannelSettingsValueCaptureRules],
    ):
        self.status_timeouts = status_timeouts
        self.capture_rules = capture_rules


"""
Nested response model for CreateConfigurationRequestChannelSettingsValueCaptureRules
"""


class CreateConfigurationRequestChannelSettingsValueCaptureRules:
    def __init__(self, _from: str, to: str, metadata: Dict[str, str]):
        self._from = _from
        self.to = to
        self.metadata = metadata


"""
Nested response model for CreateConfigurationRequestChannelSettingsValueStatusTimeouts
"""


class CreateConfigurationRequestChannelSettingsValueStatusTimeouts:
    def __init__(self, inactive: int, closed: int):
        self.inactive = inactive
        self.closed = closed


"""
Nested response model for CreateConfigurationRequestStatusCallbacks
"""


class CreateConfigurationRequestStatusCallbacks:
    def __init__(self, url: str, method: "ConfigurationInstance.str"):
        self.url = url
        self.method = method


"""
Nested response model for UpdateConfigurationRequest
"""


class UpdateConfigurationRequest:
    def __init__(
        self,
        display_name: str,
        description: str,
        conversation_grouping_type: "ConfigurationInstance.str",
        memory_store_id: str,
        channel_settings: Dict[str, UpdateConfigurationRequestChannelSettingsValue],
        status_callbacks: List[
            ConfigurationList.UpdateConfigurationRequestStatusCallbacks
        ],
        intelligence_configuration_ids: List[str],
    ):
        self.display_name = display_name
        self.description = description
        self.conversation_grouping_type = conversation_grouping_type
        self.memory_store_id = memory_store_id
        self.channel_settings = channel_settings
        self.status_callbacks = status_callbacks
        self.intelligence_configuration_ids = intelligence_configuration_ids


"""
Nested response model for UpdateConfigurationRequestChannelSettingsValue
"""


class UpdateConfigurationRequestChannelSettingsValue:
    def __init__(
        self,
        status_timeouts: UpdateConfigurationRequestChannelSettingsValueStatusTimeouts,
        capture_rules: List[UpdateConfigurationRequestChannelSettingsValueCaptureRules],
    ):
        self.status_timeouts = status_timeouts
        self.capture_rules = capture_rules


"""
Nested response model for UpdateConfigurationRequestChannelSettingsValueCaptureRules
"""


class UpdateConfigurationRequestChannelSettingsValueCaptureRules:
    def __init__(self, _from: str, to: str, metadata: Dict[str, str]):
        self._from = _from
        self.to = to
        self.metadata = metadata


"""
Nested response model for UpdateConfigurationRequestChannelSettingsValueStatusTimeouts
"""


class UpdateConfigurationRequestChannelSettingsValueStatusTimeouts:
    def __init__(self, inactive: int, closed: int):
        self.inactive = inactive
        self.closed = closed


"""
Nested response model for UpdateConfigurationRequestStatusCallbacks
"""


class UpdateConfigurationRequestStatusCallbacks:
    def __init__(self, url: str, method: "ConfigurationInstance.str"):
        self.url = url
        self.method = method


"""
Response model for ListConfiguration_400_response operations
"""


class ListConfiguration_400_responseResource:
    def __init__(self, code: int, message: str, more_info: str, status: int):
        """
        Initialize the ListConfiguration_400_responseResource
        :param code: Twilio-specific error code
        :param message: Error message
        :param more_info: Link to Error Code References
        :param status: HTTP response status code

        """
        self.code = code
        self.message = message
        self.more_info = more_info
        self.status = status


"""
Response model for ListConfiguration_200_response_configurations operations
"""


class ListConfiguration_200_response_configurationsResource:
    def __init__(
        self,
        id: str,
        displayName: str,
        description: str,
        conversationGroupingType: "ConfigurationInstance.str",
        memoryStoreId: str,
        channelSettings: Dict[str, str],
        statusCallbacks: List[str],
        intelligenceConfigurationIds: List[str],
        createdAt: datetime,
        updatedAt: datetime,
        version: int,
    ):
        """
        Initialize the ListConfiguration_200_response_configurationsResource
        :param id: Configuration ID.
        :param displayName: A human-readable name for the configuration. Limited to 32 characters.
        :param description: Human-readable description for the Configuration. Allows spaces and special characters, typically limited to a paragraph of text. This serves as a descriptive field rather than just a name.
        :param conversationGroupingType: Type of Conversation grouping strategy: - `GROUP_BY_PARTICIPANT_ADDRESSES`: Groups Communications by Participant addresses across all channels.   A customer using +18005550100 will be in the same Conversation whether they contact by SMS, WhatsApp, or RCS. - `GROUP_BY_PARTICIPANT_ADDRESSES_AND_CHANNEL_TYPE`: Groups Communications by both Participant addresses AND channel.   A customer using +18005550100 by SMS will be in a different Conversation than the same customer by Voice.
        :param memoryStoreId: Memory Store ID for Profile resolution.
        :param channelSettings: Channel-specific configuration settings by channel type. Keys should be valid channel types (`VOICE`, `SMS`, `RCS`, `WHATSAPP`, `CHAT`).
        :param statusCallbacks: List of default webhook configurations applied to Conversations under this Configuration.
        :param intelligenceConfigurationIds: A list of Conversational Intelligence configuration IDs.
        :param createdAt: Timestamp when this Configuration was created.
        :param updatedAt: Timestamp when this Configuration was last updated.
        :param version: Version number used for optimistic locking.

        """
        self.id = id
        self.displayName = displayName
        self.description = description
        self.conversationGroupingType = conversationGroupingType
        self.memoryStoreId = memoryStoreId
        self.channelSettings = channelSettings
        self.statusCallbacks = statusCallbacks
        self.intelligenceConfigurationIds = intelligenceConfigurationIds
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.version = version


class ConfigurationInstance(InstanceResource):

    class ConversationsV2CaptureRule(object):
        """
        :ivar _from: The from address. Use `*` for wildcard to match any from address.
        :ivar to: The to address. Use `*` for wildcard to match any to address.
        :ivar metadata: Additional matching criteria for the capture rule. For voice calls, can include `callType` (`PSTN`, `SIP`, and similar).
        """

        def __init__(self, payload: Dict[str, Any]):

            self._from: Optional[str] = payload.get("from")
            self.to: Optional[str] = payload.get("to")
            self.metadata: Optional[Dict[str, str]] = payload.get("metadata")

        def to_dict(self):
            return {
                "from": self._from,
                "to": self.to,
                "metadata": self.metadata,
            }

    class ConversationsV2StatusTimeouts(object):
        """
        :ivar inactive: Inactivity timeout in minutes.
        :ivar closed: Close timeout in minutes.
        """

        def __init__(self, payload: Dict[str, Any]):

            self.inactive: Optional[int] = deserialize.integer(payload.get("inactive"))
            self.closed: Optional[int] = deserialize.integer(payload.get("closed"))

        def to_dict(self):
            return {
                "inactive": self.inactive,
                "closed": self.closed,
            }

    class CreateConfigurationRequest(object):
        """
        :ivar display_name: A human-readable name for the configuration. Limited to 32 characters.
        :ivar description: Human-readable description for the configuration.
        :ivar conversation_grouping_type: The strategy Maestro (Conversations) uses to assign communications to conversations.
        :ivar memory_store_id: The memory store ID that Maestro (Conversations) uses for profile resolution.
        :ivar channel_settings:
        :ivar status_callbacks: A list of webhook configurations.
        :ivar intelligence_configuration_ids: A list of Conversational Intelligence configuration IDs.
        """

        def __init__(self, payload: Dict[str, Any]):

            self.display_name: Optional[str] = payload.get("displayName")
            self.description: Optional[str] = payload.get("description")
            self.conversation_grouping_type: Optional["ConfigurationInstance.str"] = (
                payload.get("conversationGroupingType")
            )
            self.memory_store_id: Optional[str] = payload.get("memoryStoreId")
            self.channel_settings: Optional[
                Dict[str, CreateConfigurationRequestChannelSettingsValue]
            ] = payload.get("channelSettings")
            self.status_callbacks: Optional[
                List[ConfigurationList.CreateConfigurationRequestStatusCallbacks]
            ] = payload.get("statusCallbacks")
            self.intelligence_configuration_ids: Optional[List[str]] = payload.get(
                "intelligenceConfigurationIds"
            )

        def to_dict(self):
            return {
                "displayName": self.display_name,
                "description": self.description,
                "conversationGroupingType": self.conversation_grouping_type,
                "memoryStoreId": self.memory_store_id,
                "channelSettings": (
                    [
                        channel_settings.to_dict()
                        for channel_settings in self.channel_settings
                    ]
                    if self.channel_settings is not None
                    else None
                ),
                "statusCallbacks": (
                    [
                        status_callbacks.to_dict()
                        for status_callbacks in self.status_callbacks
                    ]
                    if self.status_callbacks is not None
                    else None
                ),
                "intelligenceConfigurationIds": self.intelligence_configuration_ids,
            }

    class CreateConfigurationRequestChannelSettingsValue(object):
        """
        :ivar status_timeouts:
        :ivar capture_rules:
        """

        def __init__(self, payload: Dict[str, Any]):

            self.status_timeouts: Optional[
                CreateConfigurationRequestChannelSettingsValueStatusTimeouts
            ] = payload.get("statusTimeouts")
            self.capture_rules: Optional[
                List[CreateConfigurationRequestChannelSettingsValueCaptureRules]
            ] = payload.get("captureRules")

        def to_dict(self):
            return {
                "statusTimeouts": (
                    self.status_timeouts.to_dict()
                    if self.status_timeouts is not None
                    else None
                ),
                "captureRules": (
                    [capture_rules.to_dict() for capture_rules in self.capture_rules]
                    if self.capture_rules is not None
                    else None
                ),
            }

    class CreateConfigurationRequestChannelSettingsValueCaptureRules(object):
        """
        :ivar _from: The from address. Use '*' for wildcard.
        :ivar to: The to address. Use '*' for wildcard.
        :ivar metadata:
        """

        def __init__(self, payload: Dict[str, Any]):

            self._from: Optional[str] = payload.get("from")
            self.to: Optional[str] = payload.get("to")
            self.metadata: Optional[Dict[str, str]] = payload.get("metadata")

        def to_dict(self):
            return {
                "from": self._from,
                "to": self.to,
                "metadata": self.metadata,
            }

    class CreateConfigurationRequestChannelSettingsValueStatusTimeouts(object):
        """
        :ivar inactive: The inactivity timeout in minutes. For more information, see [Conversation lifecycle](/docs/platform/conversations/concepts/lifecycle).
        :ivar closed: The close timeout in minutes. For more information, see [Conversation lifecycle](/docs/platform/conversations/concepts/lifecycle).
        """

        def __init__(self, payload: Dict[str, Any]):

            self.inactive: Optional[int] = deserialize.integer(payload.get("inactive"))
            self.closed: Optional[int] = deserialize.integer(payload.get("closed"))

        def to_dict(self):
            return {
                "inactive": self.inactive,
                "closed": self.closed,
            }

    class CreateConfigurationRequestStatusCallbacks(object):
        """
        :ivar url: The destination URL for webhooks.
        :ivar method: The HTTP method used to invoke the webhook URL.
        """

        def __init__(self, payload: Dict[str, Any]):

            self.url: Optional[str] = payload.get("url")
            self.method: Optional["ConfigurationInstance.str"] = payload.get("method")

        def to_dict(self):
            return {
                "url": self.url,
                "method": self.method,
            }

    class UpdateConfigurationRequest(object):
        """
        :ivar display_name: A human-readable name for the configuration. Limited to 32 characters.
        :ivar description: Human-readable description for the configuration.
        :ivar conversation_grouping_type: The strategy Maestro (Conversations) uses to assign communications to conversations.
        :ivar memory_store_id: The Memory Store ID for profile resolution.
        :ivar channel_settings:
        :ivar status_callbacks:
        :ivar intelligence_configuration_ids:
        """

        def __init__(self, payload: Dict[str, Any]):

            self.display_name: Optional[str] = payload.get("displayName")
            self.description: Optional[str] = payload.get("description")
            self.conversation_grouping_type: Optional["ConfigurationInstance.str"] = (
                payload.get("conversationGroupingType")
            )
            self.memory_store_id: Optional[str] = payload.get("memoryStoreId")
            self.channel_settings: Optional[
                Dict[str, UpdateConfigurationRequestChannelSettingsValue]
            ] = payload.get("channelSettings")
            self.status_callbacks: Optional[
                List[ConfigurationList.UpdateConfigurationRequestStatusCallbacks]
            ] = payload.get("statusCallbacks")
            self.intelligence_configuration_ids: Optional[List[str]] = payload.get(
                "intelligenceConfigurationIds"
            )

        def to_dict(self):
            return {
                "displayName": self.display_name,
                "description": self.description,
                "conversationGroupingType": self.conversation_grouping_type,
                "memoryStoreId": self.memory_store_id,
                "channelSettings": (
                    [
                        channel_settings.to_dict()
                        for channel_settings in self.channel_settings
                    ]
                    if self.channel_settings is not None
                    else None
                ),
                "statusCallbacks": (
                    [
                        status_callbacks.to_dict()
                        for status_callbacks in self.status_callbacks
                    ]
                    if self.status_callbacks is not None
                    else None
                ),
                "intelligenceConfigurationIds": self.intelligence_configuration_ids,
            }

    class UpdateConfigurationRequestChannelSettingsValue(object):
        """
        :ivar status_timeouts:
        :ivar capture_rules:
        """

        def __init__(self, payload: Dict[str, Any]):

            self.status_timeouts: Optional[
                UpdateConfigurationRequestChannelSettingsValueStatusTimeouts
            ] = payload.get("statusTimeouts")
            self.capture_rules: Optional[
                List[UpdateConfigurationRequestChannelSettingsValueCaptureRules]
            ] = payload.get("captureRules")

        def to_dict(self):
            return {
                "statusTimeouts": (
                    self.status_timeouts.to_dict()
                    if self.status_timeouts is not None
                    else None
                ),
                "captureRules": (
                    [capture_rules.to_dict() for capture_rules in self.capture_rules]
                    if self.capture_rules is not None
                    else None
                ),
            }

    class UpdateConfigurationRequestChannelSettingsValueCaptureRules(object):
        """
        :ivar _from:
        :ivar to:
        :ivar metadata:
        """

        def __init__(self, payload: Dict[str, Any]):

            self._from: Optional[str] = payload.get("from")
            self.to: Optional[str] = payload.get("to")
            self.metadata: Optional[Dict[str, str]] = payload.get("metadata")

        def to_dict(self):
            return {
                "from": self._from,
                "to": self.to,
                "metadata": self.metadata,
            }

    class UpdateConfigurationRequestChannelSettingsValueStatusTimeouts(object):
        """
        :ivar inactive:
        :ivar closed:
        """

        def __init__(self, payload: Dict[str, Any]):

            self.inactive: Optional[int] = deserialize.integer(payload.get("inactive"))
            self.closed: Optional[int] = deserialize.integer(payload.get("closed"))

        def to_dict(self):
            return {
                "inactive": self.inactive,
                "closed": self.closed,
            }

    class UpdateConfigurationRequestStatusCallbacks(object):
        """
        :ivar url:
        :ivar method:
        """

        def __init__(self, payload: Dict[str, Any]):

            self.url: Optional[str] = payload.get("url")
            self.method: Optional["ConfigurationInstance.str"] = payload.get("method")

        def to_dict(self):
            return {
                "url": self.url,
                "method": self.method,
            }

    """
    :ivar id: Configuration ID.
    :ivar display_name: A human-readable name for the configuration. Limited to 32 characters.
    :ivar description: Human-readable description for the Configuration. Allows spaces and special characters, typically limited to a paragraph of text. This serves as a descriptive field rather than just a name.
    :ivar conversation_grouping_type: Type of Conversation grouping strategy: - `GROUP_BY_PARTICIPANT_ADDRESSES`: Groups Communications by Participant addresses across all channels.   A customer using +18005550100 will be in the same Conversation whether they contact by SMS, WhatsApp, or RCS. - `GROUP_BY_PARTICIPANT_ADDRESSES_AND_CHANNEL_TYPE`: Groups Communications by both Participant addresses AND channel.   A customer using +18005550100 by SMS will be in a different Conversation than the same customer by Voice. 
    :ivar memory_store_id: Memory Store ID for Profile resolution.
    :ivar channel_settings: Channel-specific configuration settings by channel type. Keys should be valid channel types (`VOICE`, `SMS`, `RCS`, `WHATSAPP`, `CHAT`).
    :ivar status_callbacks: List of default webhook configurations applied to Conversations under this Configuration.
    :ivar intelligence_configuration_ids: A list of Conversational Intelligence configuration IDs.
    :ivar created_at: Timestamp when this Configuration was created.
    :ivar updated_at: Timestamp when this Configuration was last updated.
    :ivar version: Version number used for optimistic locking.
    """

    def __init__(
        self, version: Version, payload: ResponseResource, sid: Optional[str] = None
    ):
        super().__init__(version)

        self.id: Optional[str] = payload.get("id")
        self.display_name: Optional[str] = payload.get("displayName")
        self.description: Optional[str] = payload.get("description")
        self.conversation_grouping_type: Optional["ConfigurationInstance.str"] = (
            payload.get("conversationGroupingType")
        )
        self.memory_store_id: Optional[str] = payload.get("memoryStoreId")
        self.channel_settings: Optional[Dict[str, str]] = payload.get("channelSettings")
        self.status_callbacks: Optional[List[str]] = payload.get("statusCallbacks")
        self.intelligence_configuration_ids: Optional[List[str]] = payload.get(
            "intelligenceConfigurationIds"
        )
        self.created_at: Optional[datetime] = deserialize.iso8601_datetime(
            payload.get("createdAt")
        )
        self.updated_at: Optional[datetime] = deserialize.iso8601_datetime(
            payload.get("updatedAt")
        )
        self.version: Optional[int] = payload.get("version")

        self._solution = {
            "sid": sid or self.sid,
        }
        self._context: Optional[ConfigurationContext] = None

    @property
    def _proxy(self) -> "ConfigurationContext":
        """
        Generate an instance context for the instance, the context is capable of
        performing various actions. All instance actions are proxied to the context

        :returns: ConfigurationContext for this ConfigurationInstance
        """
        if self._context is None:
            self._context = ConfigurationContext(
                self._version,
                sid=self._solution["sid"],
            )
        return self._context

    def delete(self) -> bool:
        """
        Deletes the ConfigurationInstance


        :returns: True if delete succeeds, False otherwise
        """
        return self._proxy.delete()

    async def delete_async(self) -> bool:
        """
        Asynchronous coroutine that deletes the ConfigurationInstance


        :returns: True if delete succeeds, False otherwise
        """
        return await self._proxy.delete_async()

    def delete_with_http_info(self) -> ApiResponse:
        """
        Deletes the ConfigurationInstance with HTTP info


        :returns: ApiResponse with success boolean, status code, and headers
        """
        return self._proxy.delete_with_http_info()

    async def delete_with_http_info_async(self) -> ApiResponse:
        """
        Asynchronous coroutine that deletes the ConfigurationInstance with HTTP info


        :returns: ApiResponse with success boolean, status code, and headers
        """
        return await self._proxy.delete_with_http_info_async()

    def fetch(self) -> "ConfigurationInstance":
        """
        Fetch the ConfigurationInstance


        :returns: The fetched ConfigurationInstance
        """
        return self._proxy.fetch()

    async def fetch_async(self) -> "ConfigurationInstance":
        """
        Asynchronous coroutine to fetch the ConfigurationInstance


        :returns: The fetched ConfigurationInstance
        """
        return await self._proxy.fetch_async()

    def fetch_with_http_info(self) -> ApiResponse:
        """
        Fetch the ConfigurationInstance with HTTP info


        :returns: ApiResponse with instance, status code, and headers
        """
        return self._proxy.fetch_with_http_info()

    async def fetch_with_http_info_async(self) -> ApiResponse:
        """
        Asynchronous coroutine to fetch the ConfigurationInstance with HTTP info


        :returns: ApiResponse with instance, status code, and headers
        """
        return await self._proxy.fetch_with_http_info_async()

    def update(
        self,
        update_configuration_request: Union[
            UpdateConfigurationRequest, object
        ] = values.unset,
    ) -> "ConfigurationInstance":
        """
        Update the ConfigurationInstance

        :param update_configuration_request: The configuration to update

        :returns: The updated ConfigurationInstance
        """
        return self._proxy.update(
            update_configuration_request=update_configuration_request,
        )

    async def update_async(
        self,
        update_configuration_request: Union[
            UpdateConfigurationRequest, object
        ] = values.unset,
    ) -> "ConfigurationInstance":
        """
        Asynchronous coroutine to update the ConfigurationInstance

        :param update_configuration_request: The configuration to update

        :returns: The updated ConfigurationInstance
        """
        return await self._proxy.update_async(
            update_configuration_request=update_configuration_request,
        )

    def update_with_http_info(
        self,
        update_configuration_request: Union[
            UpdateConfigurationRequest, object
        ] = values.unset,
    ) -> ApiResponse:
        """
        Update the ConfigurationInstance with HTTP info

        :param update_configuration_request: The configuration to update

        :returns: ApiResponse with instance, status code, and headers
        """
        return self._proxy.update_with_http_info(
            update_configuration_request=update_configuration_request,
        )

    async def update_with_http_info_async(
        self,
        update_configuration_request: Union[
            UpdateConfigurationRequest, object
        ] = values.unset,
    ) -> ApiResponse:
        """
        Asynchronous coroutine to update the ConfigurationInstance with HTTP info

        :param update_configuration_request: The configuration to update

        :returns: ApiResponse with instance, status code, and headers
        """
        return await self._proxy.update_with_http_info_async(
            update_configuration_request=update_configuration_request,
        )

    def __repr__(self) -> str:
        """
        Provide a friendly representation

        :returns: Machine friendly representation
        """
        context = " ".join("{}={}".format(k, v) for k, v in self._solution.items())
        return "<Twilio.Conversations.V2.ConfigurationInstance {}>".format(context)


class ConfigurationContext(InstanceContext):

    class ConversationsV2CaptureRule(object):
        """
        :ivar _from: The from address. Use `*` for wildcard to match any from address.
        :ivar to: The to address. Use `*` for wildcard to match any to address.
        :ivar metadata: Additional matching criteria for the capture rule. For voice calls, can include `callType` (`PSTN`, `SIP`, and similar).
        """

        def __init__(self, payload: Dict[str, Any]):

            self._from: Optional[str] = payload.get("from")
            self.to: Optional[str] = payload.get("to")
            self.metadata: Optional[Dict[str, str]] = payload.get("metadata")

        def to_dict(self):
            return {
                "from": self._from,
                "to": self.to,
                "metadata": self.metadata,
            }

    class ConversationsV2StatusTimeouts(object):
        """
        :ivar inactive: Inactivity timeout in minutes.
        :ivar closed: Close timeout in minutes.
        """

        def __init__(self, payload: Dict[str, Any]):

            self.inactive: Optional[int] = deserialize.integer(payload.get("inactive"))
            self.closed: Optional[int] = deserialize.integer(payload.get("closed"))

        def to_dict(self):
            return {
                "inactive": self.inactive,
                "closed": self.closed,
            }

    class CreateConfigurationRequest(object):
        """
        :ivar display_name: A human-readable name for the configuration. Limited to 32 characters.
        :ivar description: Human-readable description for the configuration.
        :ivar conversation_grouping_type: The strategy Maestro (Conversations) uses to assign communications to conversations.
        :ivar memory_store_id: The memory store ID that Maestro (Conversations) uses for profile resolution.
        :ivar channel_settings:
        :ivar status_callbacks: A list of webhook configurations.
        :ivar intelligence_configuration_ids: A list of Conversational Intelligence configuration IDs.
        """

        def __init__(self, payload: Dict[str, Any]):

            self.display_name: Optional[str] = payload.get("displayName")
            self.description: Optional[str] = payload.get("description")
            self.conversation_grouping_type: Optional["ConfigurationInstance.str"] = (
                payload.get("conversationGroupingType")
            )
            self.memory_store_id: Optional[str] = payload.get("memoryStoreId")
            self.channel_settings: Optional[
                Dict[str, CreateConfigurationRequestChannelSettingsValue]
            ] = payload.get("channelSettings")
            self.status_callbacks: Optional[
                List[ConfigurationList.CreateConfigurationRequestStatusCallbacks]
            ] = payload.get("statusCallbacks")
            self.intelligence_configuration_ids: Optional[List[str]] = payload.get(
                "intelligenceConfigurationIds"
            )

        def to_dict(self):
            return {
                "displayName": self.display_name,
                "description": self.description,
                "conversationGroupingType": self.conversation_grouping_type,
                "memoryStoreId": self.memory_store_id,
                "channelSettings": (
                    [
                        channel_settings.to_dict()
                        for channel_settings in self.channel_settings
                    ]
                    if self.channel_settings is not None
                    else None
                ),
                "statusCallbacks": (
                    [
                        status_callbacks.to_dict()
                        for status_callbacks in self.status_callbacks
                    ]
                    if self.status_callbacks is not None
                    else None
                ),
                "intelligenceConfigurationIds": self.intelligence_configuration_ids,
            }

    class CreateConfigurationRequestChannelSettingsValue(object):
        """
        :ivar status_timeouts:
        :ivar capture_rules:
        """

        def __init__(self, payload: Dict[str, Any]):

            self.status_timeouts: Optional[
                CreateConfigurationRequestChannelSettingsValueStatusTimeouts
            ] = payload.get("statusTimeouts")
            self.capture_rules: Optional[
                List[CreateConfigurationRequestChannelSettingsValueCaptureRules]
            ] = payload.get("captureRules")

        def to_dict(self):
            return {
                "statusTimeouts": (
                    self.status_timeouts.to_dict()
                    if self.status_timeouts is not None
                    else None
                ),
                "captureRules": (
                    [capture_rules.to_dict() for capture_rules in self.capture_rules]
                    if self.capture_rules is not None
                    else None
                ),
            }

    class CreateConfigurationRequestChannelSettingsValueCaptureRules(object):
        """
        :ivar _from: The from address. Use '*' for wildcard.
        :ivar to: The to address. Use '*' for wildcard.
        :ivar metadata:
        """

        def __init__(self, payload: Dict[str, Any]):

            self._from: Optional[str] = payload.get("from")
            self.to: Optional[str] = payload.get("to")
            self.metadata: Optional[Dict[str, str]] = payload.get("metadata")

        def to_dict(self):
            return {
                "from": self._from,
                "to": self.to,
                "metadata": self.metadata,
            }

    class CreateConfigurationRequestChannelSettingsValueStatusTimeouts(object):
        """
        :ivar inactive: The inactivity timeout in minutes. For more information, see [Conversation lifecycle](/docs/platform/conversations/concepts/lifecycle).
        :ivar closed: The close timeout in minutes. For more information, see [Conversation lifecycle](/docs/platform/conversations/concepts/lifecycle).
        """

        def __init__(self, payload: Dict[str, Any]):

            self.inactive: Optional[int] = deserialize.integer(payload.get("inactive"))
            self.closed: Optional[int] = deserialize.integer(payload.get("closed"))

        def to_dict(self):
            return {
                "inactive": self.inactive,
                "closed": self.closed,
            }

    class CreateConfigurationRequestStatusCallbacks(object):
        """
        :ivar url: The destination URL for webhooks.
        :ivar method: The HTTP method used to invoke the webhook URL.
        """

        def __init__(self, payload: Dict[str, Any]):

            self.url: Optional[str] = payload.get("url")
            self.method: Optional["ConfigurationInstance.str"] = payload.get("method")

        def to_dict(self):
            return {
                "url": self.url,
                "method": self.method,
            }

    class UpdateConfigurationRequest(object):
        """
        :ivar display_name: A human-readable name for the configuration. Limited to 32 characters.
        :ivar description: Human-readable description for the configuration.
        :ivar conversation_grouping_type: The strategy Maestro (Conversations) uses to assign communications to conversations.
        :ivar memory_store_id: The Memory Store ID for profile resolution.
        :ivar channel_settings:
        :ivar status_callbacks:
        :ivar intelligence_configuration_ids:
        """

        def __init__(self, payload: Dict[str, Any]):

            self.display_name: Optional[str] = payload.get("displayName")
            self.description: Optional[str] = payload.get("description")
            self.conversation_grouping_type: Optional["ConfigurationInstance.str"] = (
                payload.get("conversationGroupingType")
            )
            self.memory_store_id: Optional[str] = payload.get("memoryStoreId")
            self.channel_settings: Optional[
                Dict[str, UpdateConfigurationRequestChannelSettingsValue]
            ] = payload.get("channelSettings")
            self.status_callbacks: Optional[
                List[ConfigurationList.UpdateConfigurationRequestStatusCallbacks]
            ] = payload.get("statusCallbacks")
            self.intelligence_configuration_ids: Optional[List[str]] = payload.get(
                "intelligenceConfigurationIds"
            )

        def to_dict(self):
            return {
                "displayName": self.display_name,
                "description": self.description,
                "conversationGroupingType": self.conversation_grouping_type,
                "memoryStoreId": self.memory_store_id,
                "channelSettings": (
                    [
                        channel_settings.to_dict()
                        for channel_settings in self.channel_settings
                    ]
                    if self.channel_settings is not None
                    else None
                ),
                "statusCallbacks": (
                    [
                        status_callbacks.to_dict()
                        for status_callbacks in self.status_callbacks
                    ]
                    if self.status_callbacks is not None
                    else None
                ),
                "intelligenceConfigurationIds": self.intelligence_configuration_ids,
            }

    class UpdateConfigurationRequestChannelSettingsValue(object):
        """
        :ivar status_timeouts:
        :ivar capture_rules:
        """

        def __init__(self, payload: Dict[str, Any]):

            self.status_timeouts: Optional[
                UpdateConfigurationRequestChannelSettingsValueStatusTimeouts
            ] = payload.get("statusTimeouts")
            self.capture_rules: Optional[
                List[UpdateConfigurationRequestChannelSettingsValueCaptureRules]
            ] = payload.get("captureRules")

        def to_dict(self):
            return {
                "statusTimeouts": (
                    self.status_timeouts.to_dict()
                    if self.status_timeouts is not None
                    else None
                ),
                "captureRules": (
                    [capture_rules.to_dict() for capture_rules in self.capture_rules]
                    if self.capture_rules is not None
                    else None
                ),
            }

    class UpdateConfigurationRequestChannelSettingsValueCaptureRules(object):
        """
        :ivar _from:
        :ivar to:
        :ivar metadata:
        """

        def __init__(self, payload: Dict[str, Any]):

            self._from: Optional[str] = payload.get("from")
            self.to: Optional[str] = payload.get("to")
            self.metadata: Optional[Dict[str, str]] = payload.get("metadata")

        def to_dict(self):
            return {
                "from": self._from,
                "to": self.to,
                "metadata": self.metadata,
            }

    class UpdateConfigurationRequestChannelSettingsValueStatusTimeouts(object):
        """
        :ivar inactive:
        :ivar closed:
        """

        def __init__(self, payload: Dict[str, Any]):

            self.inactive: Optional[int] = deserialize.integer(payload.get("inactive"))
            self.closed: Optional[int] = deserialize.integer(payload.get("closed"))

        def to_dict(self):
            return {
                "inactive": self.inactive,
                "closed": self.closed,
            }

    class UpdateConfigurationRequestStatusCallbacks(object):
        """
        :ivar url:
        :ivar method:
        """

        def __init__(self, payload: Dict[str, Any]):

            self.url: Optional[str] = payload.get("url")
            self.method: Optional["ConfigurationInstance.str"] = payload.get("method")

        def to_dict(self):
            return {
                "url": self.url,
                "method": self.method,
            }

    def __init__(self, version: Version, sid: str):
        """
        Initialize the ConfigurationContext

        :param version: Version that contains the resource
        :param sid:
        """
        super().__init__(version)

        # Path Solution
        self._solution = {
            "sid": sid,
        }
        self._uri = "/ControlPlane/Configurations/{sid}".format(**self._solution)

    def _delete(self) -> tuple:
        """
        Internal helper for delete operation

        Returns:
            tuple: (success_boolean, status_code, headers)
        """

        headers = values.of({})

        headers["Accept"] = "application/json"

        return self._version.delete_with_response_info(
            method="DELETE", uri=self._uri, headers=headers
        )

    def delete(self) -> bool:
        """
        Deletes the ConfigurationInstance


        :returns: True if delete succeeds, False otherwise
        """
        success, _, _ = self._delete()
        return success

    def delete_with_http_info(self) -> ApiResponse:
        """
        Deletes the ConfigurationInstance and return response metadata


        :returns: ApiResponse with success boolean, status code, and headers
        """
        success, status_code, headers = self._delete()
        return ApiResponse(data=success, status_code=status_code, headers=headers)

    async def _delete_async(self) -> tuple:
        """
        Internal async helper for delete operation

        Returns:
            tuple: (success_boolean, status_code, headers)
        """

        headers = values.of({})

        headers["Accept"] = "application/json"

        return await self._version.delete_with_response_info_async(
            method="DELETE", uri=self._uri, headers=headers
        )

    async def delete_async(self) -> bool:
        """
        Asynchronous coroutine that deletes the ConfigurationInstance


        :returns: True if delete succeeds, False otherwise
        """
        success, _, _ = await self._delete_async()
        return success

    async def delete_with_http_info_async(self) -> ApiResponse:
        """
        Asynchronous coroutine that deletes the ConfigurationInstance and return response metadata


        :returns: ApiResponse with success boolean, status code, and headers
        """
        success, status_code, headers = await self._delete_async()
        return ApiResponse(data=success, status_code=status_code, headers=headers)

    def _fetch(self) -> tuple:
        """
        Internal helper for fetch operation

        Returns:
            tuple: (payload, status_code, headers)
        """

        headers = values.of({})

        headers["Accept"] = "application/json"

        return self._version.fetch_with_response_info(
            method="GET", uri=self._uri, headers=headers
        )

    def fetch(self) -> ConfigurationInstance:
        """
        Fetch the ConfigurationInstance


        :returns: The fetched ConfigurationInstance
        """
        payload, _, _ = self._fetch()
        return ConfigurationInstance(
            self._version,
            payload,
            sid=self._solution["sid"],
        )

    def fetch_with_http_info(self) -> ApiResponse:
        """
        Fetch the ConfigurationInstance and return response metadata


        :returns: ApiResponse with instance, status code, and headers
        """
        payload, status_code, headers = self._fetch()
        instance = ConfigurationInstance(
            self._version,
            payload,
            sid=self._solution["sid"],
        )
        return ApiResponse(data=instance, status_code=status_code, headers=headers)

    async def _fetch_async(self) -> tuple:
        """
        Internal async helper for fetch operation

        Returns:
            tuple: (payload, status_code, headers)
        """

        headers = values.of({})

        headers["Accept"] = "application/json"

        return await self._version.fetch_with_response_info_async(
            method="GET", uri=self._uri, headers=headers
        )

    async def fetch_async(self) -> ConfigurationInstance:
        """
        Asynchronous coroutine to fetch the ConfigurationInstance


        :returns: The fetched ConfigurationInstance
        """
        payload, _, _ = await self._fetch_async()
        return ConfigurationInstance(
            self._version,
            payload,
            sid=self._solution["sid"],
        )

    async def fetch_with_http_info_async(self) -> ApiResponse:
        """
        Asynchronous coroutine to fetch the ConfigurationInstance and return response metadata


        :returns: ApiResponse with instance, status code, and headers
        """
        payload, status_code, headers = await self._fetch_async()
        instance = ConfigurationInstance(
            self._version,
            payload,
            sid=self._solution["sid"],
        )
        return ApiResponse(data=instance, status_code=status_code, headers=headers)

    def _update(
        self,
        update_configuration_request: Union[
            UpdateConfigurationRequest, object
        ] = values.unset,
    ) -> tuple:
        """
        Internal helper for update operation

        Returns:
            tuple: (payload, status_code, headers)
        """
        data = update_configuration_request.to_dict()

        headers = values.of({})

        headers["Content-Type"] = "application/json"

        headers["Accept"] = "application/json"

        return self._version.update_with_response_info(
            method="PUT", uri=self._uri, data=data, headers=headers
        )

    def update(
        self,
        update_configuration_request: Union[
            UpdateConfigurationRequest, object
        ] = values.unset,
    ) -> ConfigurationInstance:
        """
        Update the ConfigurationInstance

        :param update_configuration_request: The configuration to update

        :returns: The updated ConfigurationInstance
        """
        payload, _, _ = self._update(
            update_configuration_request=update_configuration_request
        )
        return ConfigurationInstance(self._version, payload, sid=self._solution["sid"])

    def update_with_http_info(
        self,
        update_configuration_request: Union[
            UpdateConfigurationRequest, object
        ] = values.unset,
    ) -> ApiResponse:
        """
        Update the ConfigurationInstance and return response metadata

        :param update_configuration_request: The configuration to update

        :returns: ApiResponse with instance, status code, and headers
        """
        payload, status_code, headers = self._update(
            update_configuration_request=update_configuration_request
        )
        instance = ConfigurationInstance(
            self._version, payload, sid=self._solution["sid"]
        )
        return ApiResponse(data=instance, status_code=status_code, headers=headers)

    async def _update_async(
        self,
        update_configuration_request: Union[
            UpdateConfigurationRequest, object
        ] = values.unset,
    ) -> tuple:
        """
        Internal async helper for update operation

        Returns:
            tuple: (payload, status_code, headers)
        """
        data = update_configuration_request.to_dict()

        headers = values.of({})

        headers["Content-Type"] = "application/json"

        headers["Accept"] = "application/json"

        return await self._version.update_with_response_info_async(
            method="PUT", uri=self._uri, data=data, headers=headers
        )

    async def update_async(
        self,
        update_configuration_request: Union[
            UpdateConfigurationRequest, object
        ] = values.unset,
    ) -> ConfigurationInstance:
        """
        Asynchronous coroutine to update the ConfigurationInstance

        :param update_configuration_request: The configuration to update

        :returns: The updated ConfigurationInstance
        """
        payload, _, _ = await self._update_async(
            update_configuration_request=update_configuration_request
        )
        return ConfigurationInstance(self._version, payload, sid=self._solution["sid"])

    async def update_with_http_info_async(
        self,
        update_configuration_request: Union[
            UpdateConfigurationRequest, object
        ] = values.unset,
    ) -> ApiResponse:
        """
        Asynchronous coroutine to update the ConfigurationInstance and return response metadata

        :param update_configuration_request: The configuration to update

        :returns: ApiResponse with instance, status code, and headers
        """
        payload, status_code, headers = await self._update_async(
            update_configuration_request=update_configuration_request
        )
        instance = ConfigurationInstance(
            self._version, payload, sid=self._solution["sid"]
        )
        return ApiResponse(data=instance, status_code=status_code, headers=headers)

    def __repr__(self) -> str:
        """
        Provide a friendly representation

        :returns: Machine friendly representation
        """
        context = " ".join("{}={}".format(k, v) for k, v in self._solution.items())
        return "<Twilio.Conversations.V2.ConfigurationContext {}>".format(context)


class ConfigurationPage(TokenPagination):

    def get_instance(self, payload: Dict[str, Any]) -> ConfigurationInstance:
        """
        Build an instance of ConfigurationInstance

        :param payload: Payload response from the API
        """
        return ConfigurationInstance(self._version, payload)

    def __repr__(self) -> str:
        """
        Provide a friendly representation

        :returns: Machine friendly representation
        """
        return "<Twilio.Conversations.V2.ConfigurationPage>"


class ConfigurationList(ListResource):

    class ConversationsV2CaptureRule(object):
        """
        :ivar _from: The from address. Use `*` for wildcard to match any from address.
        :ivar to: The to address. Use `*` for wildcard to match any to address.
        :ivar metadata: Additional matching criteria for the capture rule. For voice calls, can include `callType` (`PSTN`, `SIP`, and similar).
        """

        def __init__(self, payload: Dict[str, Any]):

            self._from: Optional[str] = payload.get("from")
            self.to: Optional[str] = payload.get("to")
            self.metadata: Optional[Dict[str, str]] = payload.get("metadata")

        def to_dict(self):
            return {
                "from": self._from,
                "to": self.to,
                "metadata": self.metadata,
            }

    class ConversationsV2StatusTimeouts(object):
        """
        :ivar inactive: Inactivity timeout in minutes.
        :ivar closed: Close timeout in minutes.
        """

        def __init__(self, payload: Dict[str, Any]):

            self.inactive: Optional[int] = deserialize.integer(payload.get("inactive"))
            self.closed: Optional[int] = deserialize.integer(payload.get("closed"))

        def to_dict(self):
            return {
                "inactive": self.inactive,
                "closed": self.closed,
            }

    class CreateConfigurationRequest(object):
        """
        :ivar display_name: A human-readable name for the configuration. Limited to 32 characters.
        :ivar description: Human-readable description for the configuration.
        :ivar conversation_grouping_type: The strategy Maestro (Conversations) uses to assign communications to conversations.
        :ivar memory_store_id: The memory store ID that Maestro (Conversations) uses for profile resolution.
        :ivar channel_settings:
        :ivar status_callbacks: A list of webhook configurations.
        :ivar intelligence_configuration_ids: A list of Conversational Intelligence configuration IDs.
        """

        def __init__(self, payload: Dict[str, Any]):

            self.display_name: Optional[str] = payload.get("displayName")
            self.description: Optional[str] = payload.get("description")
            self.conversation_grouping_type: Optional["ConfigurationInstance.str"] = (
                payload.get("conversationGroupingType")
            )
            self.memory_store_id: Optional[str] = payload.get("memoryStoreId")
            self.channel_settings: Optional[
                Dict[str, CreateConfigurationRequestChannelSettingsValue]
            ] = payload.get("channelSettings")
            self.status_callbacks: Optional[
                List[ConfigurationList.CreateConfigurationRequestStatusCallbacks]
            ] = payload.get("statusCallbacks")
            self.intelligence_configuration_ids: Optional[List[str]] = payload.get(
                "intelligenceConfigurationIds"
            )

        def to_dict(self):
            return {
                "displayName": self.display_name,
                "description": self.description,
                "conversationGroupingType": self.conversation_grouping_type,
                "memoryStoreId": self.memory_store_id,
                "channelSettings": (
                    [
                        channel_settings.to_dict()
                        for channel_settings in self.channel_settings
                    ]
                    if self.channel_settings is not None
                    else None
                ),
                "statusCallbacks": (
                    [
                        status_callbacks.to_dict()
                        for status_callbacks in self.status_callbacks
                    ]
                    if self.status_callbacks is not None
                    else None
                ),
                "intelligenceConfigurationIds": self.intelligence_configuration_ids,
            }

    class CreateConfigurationRequestChannelSettingsValue(object):
        """
        :ivar status_timeouts:
        :ivar capture_rules:
        """

        def __init__(self, payload: Dict[str, Any]):

            self.status_timeouts: Optional[
                CreateConfigurationRequestChannelSettingsValueStatusTimeouts
            ] = payload.get("statusTimeouts")
            self.capture_rules: Optional[
                List[CreateConfigurationRequestChannelSettingsValueCaptureRules]
            ] = payload.get("captureRules")

        def to_dict(self):
            return {
                "statusTimeouts": (
                    self.status_timeouts.to_dict()
                    if self.status_timeouts is not None
                    else None
                ),
                "captureRules": (
                    [capture_rules.to_dict() for capture_rules in self.capture_rules]
                    if self.capture_rules is not None
                    else None
                ),
            }

    class CreateConfigurationRequestChannelSettingsValueCaptureRules(object):
        """
        :ivar _from: The from address. Use '*' for wildcard.
        :ivar to: The to address. Use '*' for wildcard.
        :ivar metadata:
        """

        def __init__(self, payload: Dict[str, Any]):

            self._from: Optional[str] = payload.get("from")
            self.to: Optional[str] = payload.get("to")
            self.metadata: Optional[Dict[str, str]] = payload.get("metadata")

        def to_dict(self):
            return {
                "from": self._from,
                "to": self.to,
                "metadata": self.metadata,
            }

    class CreateConfigurationRequestChannelSettingsValueStatusTimeouts(object):
        """
        :ivar inactive: The inactivity timeout in minutes. For more information, see [Conversation lifecycle](/docs/platform/conversations/concepts/lifecycle).
        :ivar closed: The close timeout in minutes. For more information, see [Conversation lifecycle](/docs/platform/conversations/concepts/lifecycle).
        """

        def __init__(self, payload: Dict[str, Any]):

            self.inactive: Optional[int] = deserialize.integer(payload.get("inactive"))
            self.closed: Optional[int] = deserialize.integer(payload.get("closed"))

        def to_dict(self):
            return {
                "inactive": self.inactive,
                "closed": self.closed,
            }

    class CreateConfigurationRequestStatusCallbacks(object):
        """
        :ivar url: The destination URL for webhooks.
        :ivar method: The HTTP method used to invoke the webhook URL.
        """

        def __init__(self, payload: Dict[str, Any]):

            self.url: Optional[str] = payload.get("url")
            self.method: Optional["ConfigurationInstance.str"] = payload.get("method")

        def to_dict(self):
            return {
                "url": self.url,
                "method": self.method,
            }

    class UpdateConfigurationRequest(object):
        """
        :ivar display_name: A human-readable name for the configuration. Limited to 32 characters.
        :ivar description: Human-readable description for the configuration.
        :ivar conversation_grouping_type: The strategy Maestro (Conversations) uses to assign communications to conversations.
        :ivar memory_store_id: The Memory Store ID for profile resolution.
        :ivar channel_settings:
        :ivar status_callbacks:
        :ivar intelligence_configuration_ids:
        """

        def __init__(self, payload: Dict[str, Any]):

            self.display_name: Optional[str] = payload.get("displayName")
            self.description: Optional[str] = payload.get("description")
            self.conversation_grouping_type: Optional["ConfigurationInstance.str"] = (
                payload.get("conversationGroupingType")
            )
            self.memory_store_id: Optional[str] = payload.get("memoryStoreId")
            self.channel_settings: Optional[
                Dict[str, UpdateConfigurationRequestChannelSettingsValue]
            ] = payload.get("channelSettings")
            self.status_callbacks: Optional[
                List[ConfigurationList.UpdateConfigurationRequestStatusCallbacks]
            ] = payload.get("statusCallbacks")
            self.intelligence_configuration_ids: Optional[List[str]] = payload.get(
                "intelligenceConfigurationIds"
            )

        def to_dict(self):
            return {
                "displayName": self.display_name,
                "description": self.description,
                "conversationGroupingType": self.conversation_grouping_type,
                "memoryStoreId": self.memory_store_id,
                "channelSettings": (
                    [
                        channel_settings.to_dict()
                        for channel_settings in self.channel_settings
                    ]
                    if self.channel_settings is not None
                    else None
                ),
                "statusCallbacks": (
                    [
                        status_callbacks.to_dict()
                        for status_callbacks in self.status_callbacks
                    ]
                    if self.status_callbacks is not None
                    else None
                ),
                "intelligenceConfigurationIds": self.intelligence_configuration_ids,
            }

    class UpdateConfigurationRequestChannelSettingsValue(object):
        """
        :ivar status_timeouts:
        :ivar capture_rules:
        """

        def __init__(self, payload: Dict[str, Any]):

            self.status_timeouts: Optional[
                UpdateConfigurationRequestChannelSettingsValueStatusTimeouts
            ] = payload.get("statusTimeouts")
            self.capture_rules: Optional[
                List[UpdateConfigurationRequestChannelSettingsValueCaptureRules]
            ] = payload.get("captureRules")

        def to_dict(self):
            return {
                "statusTimeouts": (
                    self.status_timeouts.to_dict()
                    if self.status_timeouts is not None
                    else None
                ),
                "captureRules": (
                    [capture_rules.to_dict() for capture_rules in self.capture_rules]
                    if self.capture_rules is not None
                    else None
                ),
            }

    class UpdateConfigurationRequestChannelSettingsValueCaptureRules(object):
        """
        :ivar _from:
        :ivar to:
        :ivar metadata:
        """

        def __init__(self, payload: Dict[str, Any]):

            self._from: Optional[str] = payload.get("from")
            self.to: Optional[str] = payload.get("to")
            self.metadata: Optional[Dict[str, str]] = payload.get("metadata")

        def to_dict(self):
            return {
                "from": self._from,
                "to": self.to,
                "metadata": self.metadata,
            }

    class UpdateConfigurationRequestChannelSettingsValueStatusTimeouts(object):
        """
        :ivar inactive:
        :ivar closed:
        """

        def __init__(self, payload: Dict[str, Any]):

            self.inactive: Optional[int] = deserialize.integer(payload.get("inactive"))
            self.closed: Optional[int] = deserialize.integer(payload.get("closed"))

        def to_dict(self):
            return {
                "inactive": self.inactive,
                "closed": self.closed,
            }

    class UpdateConfigurationRequestStatusCallbacks(object):
        """
        :ivar url:
        :ivar method:
        """

        def __init__(self, payload: Dict[str, Any]):

            self.url: Optional[str] = payload.get("url")
            self.method: Optional["ConfigurationInstance.str"] = payload.get("method")

        def to_dict(self):
            return {
                "url": self.url,
                "method": self.method,
            }

    def __init__(self, version: Version):
        """
        Initialize the ConfigurationList

        :param version: Version that contains the resource

        """
        super().__init__(version)

        self._uri = "/ControlPlane/Configurations"

    def _create(
        self,
        create_configuration_request: Union[
            CreateConfigurationRequest, object
        ] = values.unset,
    ) -> tuple:
        """
        Internal helper for create operation

        Returns:
            tuple: (payload, status_code, headers)
        """
        data = create_configuration_request.to_dict()

        headers = values.of({"Content-Type": "application/x-www-form-urlencoded"})

        headers["Content-Type"] = "application/json"

        headers["Accept"] = "application/json"

        return self._version.create_with_response_info(
            method="POST", uri=self._uri, data=data, headers=headers
        )

    def create(
        self,
        create_configuration_request: Union[
            CreateConfigurationRequest, object
        ] = values.unset,
    ) -> ConfigurationInstance:
        """
        Create the ConfigurationInstance

        :param create_configuration_request: The configuration to create

        :returns: The created ConfigurationInstance
        """
        payload, _, _ = self._create(
            create_configuration_request=create_configuration_request
        )
        return ConfigurationInstance(self._version, payload)

    def create_with_http_info(
        self,
        create_configuration_request: Union[
            CreateConfigurationRequest, object
        ] = values.unset,
    ) -> ApiResponse:
        """
        Create the ConfigurationInstance and return response metadata

        :param create_configuration_request: The configuration to create

        :returns: ApiResponse with instance, status code, and headers
        """
        payload, status_code, headers = self._create(
            create_configuration_request=create_configuration_request
        )
        instance = ConfigurationInstance(self._version, payload)
        return ApiResponse(data=instance, status_code=status_code, headers=headers)

    async def _create_async(
        self,
        create_configuration_request: Union[
            CreateConfigurationRequest, object
        ] = values.unset,
    ) -> tuple:
        """
        Internal async helper for create operation

        Returns:
            tuple: (payload, status_code, headers)
        """
        data = create_configuration_request.to_dict()

        headers = values.of({"Content-Type": "application/x-www-form-urlencoded"})

        headers["Content-Type"] = "application/json"

        headers["Accept"] = "application/json"

        return await self._version.create_with_response_info_async(
            method="POST", uri=self._uri, data=data, headers=headers
        )

    async def create_async(
        self,
        create_configuration_request: Union[
            CreateConfigurationRequest, object
        ] = values.unset,
    ) -> ConfigurationInstance:
        """
        Asynchronously create the ConfigurationInstance

        :param create_configuration_request: The configuration to create

        :returns: The created ConfigurationInstance
        """
        payload, _, _ = await self._create_async(
            create_configuration_request=create_configuration_request
        )
        return ConfigurationInstance(self._version, payload)

    async def create_with_http_info_async(
        self,
        create_configuration_request: Union[
            CreateConfigurationRequest, object
        ] = values.unset,
    ) -> ApiResponse:
        """
        Asynchronously create the ConfigurationInstance and return response metadata

        :param create_configuration_request: The configuration to create

        :returns: ApiResponse with instance, status code, and headers
        """
        payload, status_code, headers = await self._create_async(
            create_configuration_request=create_configuration_request
        )
        instance = ConfigurationInstance(self._version, payload)
        return ApiResponse(data=instance, status_code=status_code, headers=headers)

    def stream(
        self,
        page_token: Union[str, object] = values.unset,
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> Iterator[ConfigurationInstance]:
        """
        Streams ConfigurationInstance records from the API as a generator stream.
        This operation lazily loads records as efficiently as possible until the limit
        is reached.
        The results are returned as a generator, so this operation is memory efficient.

        :param str page_token: A URL-safe, base64-encoded token representing the page of results to return
        :param limit: Upper limit for the number of records to return. stream()
                      guarantees to never return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, stream() will attempt to read the
                          limit with the most efficient page size, i.e. min(limit, 1000)

        :returns: Generator that will yield up to limit results
        """
        limits = self._version.read_limits(limit, page_size)
        page = self.page(page_token=page_token, page_size=limits["page_size"])

        return self._version.stream(page, limits["limit"])

    async def stream_async(
        self,
        page_token: Union[str, object] = values.unset,
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> AsyncIterator[ConfigurationInstance]:
        """
        Asynchronously streams ConfigurationInstance records from the API as a generator stream.
        This operation lazily loads records as efficiently as possible until the limit
        is reached.
        The results are returned as a generator, so this operation is memory efficient.

        :param str page_token: A URL-safe, base64-encoded token representing the page of results to return
        :param limit: Upper limit for the number of records to return. stream()
                      guarantees to never return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, stream() will attempt to read the
                          limit with the most efficient page size, i.e. min(limit, 1000)

        :returns: Generator that will yield up to limit results
        """
        limits = self._version.read_limits(limit, page_size)
        page = await self.page_async(
            page_token=page_token, page_size=limits["page_size"]
        )

        return self._version.stream_async(page, limits["limit"])

    def stream_with_http_info(
        self,
        page_token: Union[str, object] = values.unset,
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> tuple:
        """
        Streams ConfigurationInstance and returns headers from first page


        :param str page_token: A URL-safe, base64-encoded token representing the page of results to return
        :param limit: Upper limit for the number of records to return. stream()
                      guarantees to never return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, stream() will attempt to read the
                          limit with the most efficient page size, i.e. min(limit, 1000)

        :returns: tuple of (generator, status_code, headers) where generator yields instances
        """
        limits = self._version.read_limits(limit, page_size)
        page_response = self.page_with_http_info(
            page_token=page_token, page_size=limits["page_size"]
        )

        generator = self._version.stream(page_response.data, limits["limit"])
        return (generator, page_response.status_code, page_response.headers)

    async def stream_with_http_info_async(
        self,
        page_token: Union[str, object] = values.unset,
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> tuple:
        """
        Asynchronously streams ConfigurationInstance and returns headers from first page


        :param str page_token: A URL-safe, base64-encoded token representing the page of results to return
        :param limit: Upper limit for the number of records to return. stream()
                      guarantees to never return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, stream() will attempt to read the
                          limit with the most efficient page size, i.e. min(limit, 1000)

        :returns: tuple of (generator, status_code, headers) where generator yields instances
        """
        limits = self._version.read_limits(limit, page_size)
        page_response = await self.page_with_http_info_async(
            page_token=page_token, page_size=limits["page_size"]
        )

        generator = self._version.stream_async(page_response.data, limits["limit"])
        return (generator, page_response.status_code, page_response.headers)

    def list(
        self,
        page_token: Union[str, object] = values.unset,
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> List[ConfigurationInstance]:
        """
        Lists ConfigurationInstance records from the API as a list.
        Unlike stream(), this operation is eager and will load `limit` records into
        memory before returning.

        :param str page_token: A URL-safe, base64-encoded token representing the page of results to return
        :param limit: Upper limit for the number of records to return. list() guarantees
                      never to return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, list() will attempt to read the limit
                          with the most efficient page size, i.e. min(limit, 1000)

        :returns: list that will contain up to limit results
        """
        return list(
            self.stream(
                page_token=page_token,
                limit=limit,
                page_size=page_size,
            )
        )

    async def list_async(
        self,
        page_token: Union[str, object] = values.unset,
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> List[ConfigurationInstance]:
        """
        Asynchronously lists ConfigurationInstance records from the API as a list.
        Unlike stream(), this operation is eager and will load `limit` records into
        memory before returning.

        :param str page_token: A URL-safe, base64-encoded token representing the page of results to return
        :param limit: Upper limit for the number of records to return. list() guarantees
                      never to return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, list() will attempt to read the limit
                          with the most efficient page size, i.e. min(limit, 1000)

        :returns: list that will contain up to limit results
        """
        return [
            record
            async for record in await self.stream_async(
                page_token=page_token,
                limit=limit,
                page_size=page_size,
            )
        ]

    def list_with_http_info(
        self,
        page_token: Union[str, object] = values.unset,
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> ApiResponse:
        """
        Lists ConfigurationInstance and returns headers from first page


        :param str page_token: A URL-safe, base64-encoded token representing the page of results to return
        :param limit: Upper limit for the number of records to return. list() guarantees
                      never to return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, list() will attempt to read the limit
                          with the most efficient page size, i.e. min(limit, 1000)

        :returns: ApiResponse with list of instances, status code, and headers
        """
        generator, status_code, headers = self.stream_with_http_info(
            page_token=page_token,
            limit=limit,
            page_size=page_size,
        )
        items = list(generator)
        return ApiResponse(data=items, status_code=status_code, headers=headers)

    async def list_with_http_info_async(
        self,
        page_token: Union[str, object] = values.unset,
        limit: Optional[int] = None,
        page_size: Optional[int] = None,
    ) -> ApiResponse:
        """
        Asynchronously lists ConfigurationInstance and returns headers from first page


        :param str page_token: A URL-safe, base64-encoded token representing the page of results to return
        :param limit: Upper limit for the number of records to return. list() guarantees
                      never to return more than limit.  Default is no limit
        :param page_size: Number of records to fetch per request, when not set will use
                          the default value of 50 records.  If no page_size is defined
                          but a limit is defined, list() will attempt to read the limit
                          with the most efficient page size, i.e. min(limit, 1000)

        :returns: ApiResponse with list of instances, status code, and headers
        """
        generator, status_code, headers = await self.stream_with_http_info_async(
            page_token=page_token,
            limit=limit,
            page_size=page_size,
        )
        items = [record async for record in generator]
        return ApiResponse(data=items, status_code=status_code, headers=headers)

    def page(
        self,
        page_size: Union[int, object] = values.unset,
        page_token: Union[str, object] = values.unset,
    ) -> ConfigurationPage:
        """
        Retrieve a single page of ConfigurationInstance records from the API.
        Request is executed immediately

        :param page_size: Maximum number of items to return in a single response
        :param page_token: A URL-safe, base64-encoded token representing the page of results to return
        :returns: Page of ConfigurationInstance
        """
        data = values.of(
            {
                "pageSize": page_size,
                "pageToken": page_token,
            }
        )

        headers = values.of({"Content-Type": "application/x-www-form-urlencoded"})

        headers["Accept"] = "application/json"

        response = self._version.page(
            method="GET", uri=self._uri, params=data, headers=headers
        )
        return ConfigurationPage(self._version, response, uri=self._uri, params=data)

    async def page_async(
        self,
        page_size: Union[int, object] = values.unset,
        page_token: Union[str, object] = values.unset,
    ) -> ConfigurationPage:
        """
        Asynchronously retrieve a single page of ConfigurationInstance records from the API.
        Request is executed immediately

        :param page_size: Maximum number of items to return in a single response
        :param page_token: A URL-safe, base64-encoded token representing the page of results to return
        :returns: Page of ConfigurationInstance
        """
        data = values.of(
            {
                "pageSize": page_size,
                "pageToken": page_token,
            }
        )

        headers = values.of({"Content-Type": "application/x-www-form-urlencoded"})

        headers["Accept"] = "application/json"

        response = await self._version.page_async(
            method="GET", uri=self._uri, params=data, headers=headers
        )
        return ConfigurationPage(self._version, response, uri=self._uri, params=data)

    def page_with_http_info(
        self,
        page_token: Union[str, object] = values.unset,
        page_number: Union[int, object] = values.unset,
        page_size: Union[int, object] = values.unset,
    ) -> ApiResponse:
        """
        Retrieve a single page with response metadata


        :param page_token: A URL-safe, base64-encoded token representing the page of results to return
        :param page_token: PageToken provided by the API
        :param page_number: Page Number, this value is simply for client state
        :param page_size: Number of records to return, defaults to 50

        :returns: ApiResponse with ConfigurationPage, status code, and headers
        """
        data = values.of(
            {
                "pageToken": page_token,
                "PageToken": page_token,
                "Page": page_number,
                "PageSize": page_size,
            }
        )

        headers = values.of({"Content-Type": "application/x-www-form-urlencoded"})

        headers["Accept"] = "application/json"

        response, status_code, response_headers = self._version.page_with_response_info(
            method="GET", uri=self._uri, params=data, headers=headers
        )
        page = ConfigurationPage(self._version, response, uri=self._uri)
        return ApiResponse(data=page, status_code=status_code, headers=response_headers)

    async def page_with_http_info_async(
        self,
        page_token: Union[str, object] = values.unset,
        page_token: Union[str, object] = values.unset,
        page_number: Union[int, object] = values.unset,
        page_size: Union[int, object] = values.unset,
    ) -> ApiResponse:
        """
        Asynchronously retrieve a single page with response metadata


        :param page_token: A URL-safe, base64-encoded token representing the page of results to return
        :param page_token: PageToken provided by the API
        :param page_number: Page Number, this value is simply for client state
        :param page_size: Number of records to return, defaults to 50

        :returns: ApiResponse with ConfigurationPage, status code, and headers
        """
        data = values.of(
            {
                "pageToken": page_token,
                "PageToken": page_token,
                "Page": page_number,
                "PageSize": page_size,
            }
        )

        headers = values.of({"Content-Type": "application/x-www-form-urlencoded"})

        headers["Accept"] = "application/json"

        response, status_code, response_headers = (
            await self._version.page_with_response_info_async(
                method="GET", uri=self._uri, params=data, headers=headers
            )
        )
        page = ConfigurationPage(self._version, response)
        return ApiResponse(data=page, status_code=status_code, headers=response_headers)

    def get_page(self, target_url: str) -> ConfigurationPage:
        """
        Retrieve a specific page of ConfigurationInstance records from the API.
        Request is executed immediately

        :param target_url: API-generated URL for the requested results page

        :returns: Page of ConfigurationInstance
        """
        response = self._version.domain.twilio.request("GET", target_url)
        return ConfigurationPage(self._version, response)

    async def get_page_async(self, target_url: str) -> ConfigurationPage:
        """
        Asynchronously retrieve a specific page of ConfigurationInstance records from the API.
        Request is executed immediately

        :param target_url: API-generated URL for the requested results page

        :returns: Page of ConfigurationInstance
        """
        response = await self._version.domain.twilio.request_async("GET", target_url)
        return ConfigurationPage(self._version, response)

    def get(self, sid: str) -> ConfigurationContext:
        """
        Constructs a ConfigurationContext

        :param sid:
        """
        return ConfigurationContext(self._version, sid=sid)

    def __call__(self, sid: str) -> ConfigurationContext:
        """
        Constructs a ConfigurationContext

        :param sid:
        """
        return ConfigurationContext(self._version, sid=sid)

    def __repr__(self) -> str:
        """
        Provide a friendly representation

        :returns: Machine friendly representation
        """
        return "<Twilio.Conversations.V2.ConfigurationList>"
